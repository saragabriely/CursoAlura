
-- Desenvolvedor C# ----------------------------------------------------

 * 01 - Aula 03 - Declarando e Populando Arrays (TRANSRIÇÃO)

 . Código inicial

namespace CSharpCollections
{
    class Program
    {
        static void Main(string[] args)
        {
            string aulaIntro = "Introdução às Coleções";
            string aulaModelando = "Modelando a Classe Aula";
            string aulaSets = "Trabalhando com Conjuntos";

            string[] aulas = new string[]
            {
                aulaIntro, aulaModelando,  aulaSets
            };
        }
    }
}

 . O primeiro deles começa no índice 0, o segundo no 1 e o último no 2. Ou seja, o 
 índice de um elemento será igual à sua posição menos um. 

 . A outra forma de declararmos um array: incluindo o tamanho que ele 
 irá ocupar, algo que foi declarado implicitamente na primeira forma. 

 . Um array é uma coleção de tamanho fixo! ==> string[] aulas = new string[3];

 . Rodando desta forma, o array armazena três posições com valor null (nulo).

 . Populando o array:

		string[] aulas = new string[3];
		aulas[0] = aulaIntro;
		aulas[1] = aulaModelando;
		aulas[2] = aulaSets;

 . Imprimindo na tela com Console.WriteLine() (atalho "cw + Tab + Tab":)

	string[] aulas = new string[3];
	aulas[0] = aulaIntro;
	aulas[1] = aulaModelando;
	aulas[2] = aulaSets;

	Console.WriteLine(aulas); -- Não é o jeito certo

 . Imprimir os resultados varrendo o array: é utilizar a instrução foreach para 
 informar  que, para cada aula em aulas, se faça algo (que no caso é a impressão).

	string[] aulas = new string[3];
	aulas[0] = aulaIntro;
	aulas[1] = aulaModelando;
	aulas[2] = aulaSets;

	Console.WriteLine(aulas);

	foreach (var aula in aulas)
	{
		Console.WriteLine(aula);
	}

 . Resultado da impressão: 

   Introdução às Coleções
   Modelando a Classe Aula
   Trabalhando com Conjuntos
  
 . Criar um método para impressão. Atalho: Selecionar o código desejado e
 "Ctrl + . (ponto)" - Extrair, nomear o método para Imprimir().

 . Imprimir o array utilizando um FOR:

private static void Imprimir(string[] aulas)
{
    //foreach (var aula in aulas)
    //{
    //  Console.WriteLine(aula);
    //}

    for (int i = 0; i < aulas.Length; i++)
    {
        Console.WriteLine(aulas[i]);
    }
}

 . O resultado da impressão será o mesmo.

 . O foreach não precisa de tantas informações!

 . Acessando o primeiro elemento (indice 0): ----------------

{
    Console.WriteLine(aulas[0]);
}

 . Acessando o último elemento: ----------------------------
{
    Console.WriteLine(aulas);

    Imprimir(aulas);

    Console.WriteLine(aulas[0]);
    Console.WriteLine(aulas[aulas.Length - 1]);
}

 . Trocar um elemento do array! -------------------------------

{
    Console.WriteLine(aulas[0]);
    Console.WriteLine(aulas[aulas.Length - 1]);

    aulaIntro = "Trabalhando com Arrays";
    Imprimir(aulas);
}

  . Neste caso, aulaIntro não diz respeito ao array AULAS, e para realmente alterar
  o valor, deverá ser da seguinte forma:

{ 
    aulas[0] = "Trabalhando com Arrays";
    Imprimir(aulas);
}

 //--------------------------------------------------------------------

	* 01 - Aula 06 - Operações com Arrays

 . Procurar um elemento no array: a aula "Modelando a Classe Aula", utilizando o
 método estático IndexOf da classe Array que buscará a primeira 
 ocorrência de uma string, retornando o índice onde foi encontrado:

	aulas[0] = "Trabalhando com Arrays";
	Imprimir(aulas);

	Console.WriteLine("Aula modelando está no índice " + 
	Array.IndexOf(aulas, aulaModelando));

 . Ao rodarmos a aplicação, será exibido o texto "A aula modelando está no índice 1".
 É a primeira ocorrência desta string no array de strings. Digamos que este texto se
 repita algumas vezes no nosso array, então é possível procurá-la assim:

aulas[0] = "Trabalhando com Arrays";
Imprimir(aulas);

Console.WriteLine("Aula modelando está no índice " + Array.IndexOf(aulas, aulaModelando));
Console.WriteLine(Array.LastIndexOf(aulas, aulaModelando));

 . Rodando a app mais uma vez, a aula será encontrada no índice 1 por tratar-se da
 primeira e última ocorrência desta string no array. Prosseguindo, faremos uma 
 operação para trocar a ordem dos elementos, colocando o último como primeiro, e 
 vice-versa.

Para revertermos o array, chamaremos o método estático do Array chamado Reverse():

Console.WriteLine("Aula modelando está no índice " + Array.IndexOf(aulas, aulaModelando));
Console.WriteLine(Array.LastIndexOf(aulas, aulaModelando));

Array.Reverse(aulas);
Imprimir(aulas);

 . Em contrapartida, para voltar o Array para sua ordem original, faremos a reversão
 mais uma vez:

Console.WriteLine("Aula modelando está no índice " + Array.IndexOf(aulas, aulaModelando));
Console.WriteLine(Array.LastIndexOf(aulas, aulaModelando));

Array.Reverse(aulas);
Imprimir(aulas);

Array.Reverse(aulas);
Imprimir(aulas);

 . Vimos, então, que o método Reverse() funciona como um método idempotente, ou seja,
 se ele for rodado duas vezes, volta-se ao estado original. Supondo que tenhamos que 
 redimensionar um array, reduzindo seu tamanho, a classe Array também permite que se
 faça isto, por meio do método estático denominado "Redimensionar", ou "Resize", não 
 esquecendo de imprimir aulas de novo:

Array.Reverse(aulas);
Imprimir(aulas);

Array.Reverse(aulas);
Imprimir(aulas);

Array.Resize(ref aulas, 2);
Imprimir(aulas);

 . No entanto, como conseguimos redimensionar um array, se ele é um tipo de 
 coleção de tamanho fixo? O que acontece é que, internamente, o Resize() cria uma 
 nova coleção (array) com o tamanho definido (neste caso, 2) e, em seguida, copia os
 primeiros elementos da nossa classe original para este array de destino. No final, 
 troca-se a referência da variável aulas apontando-a para o novo array.

 . Ou seja, sem que tivéssemos visto, uma cópia interna é criada. Este é o pequeno
 "truque" que acontece no método Resize(). Se quiséssemos aumentar o nosso array 
 novamente, para o tamanho 3, poderemos tentar:

Array.Reverse(aulas);
Imprimir(aulas);

Array.Resize(ref aulas, 2);
Imprimir(aulas);

Array.Resize(ref aulas, 3);
Imprimir(aulas);

 . Rodaremos de novo a app e teremos exatamente o mesmo resultado. Para confirmar 
 que esta alteração foi de fato realizada, colocaremos um breakpoint nesta última 
 linha que acabamos de criar, rodaremos a aplicação e inspecionaremos o array aulas.

 . Ao fazermos isto, veremos 3 elementos, cujo último deles, de índice 2, está 
 com valor nulo, o que ocorre porque este elemento (ou índice) está vago, ou seja,
 não há nenhum valor dentro dele.

 . É preciso, então, preenchermos esta última posição com um valor. Digamos que 
 queiramos colocar a última aula como sendo a de conclusão. Para atribuirmos um 
 valor a ela, colocaremos entre colchetes o índice que queremos usar.

O índice da última aula é 2, portanto o código ficará assim:

Array.Resize(ref aulas, 3);
Imprimir(aulas);

aulas[2] = "Conclusão";
Se tivermos um array cujo tamanho desconhecemos e quisermos preencher a última posição deste array, não poderemos simplesmente colocar 2, que no caso seria o número mágico, e sim uma expressão que sempre acesse a última posição do array.

Sendo o índice sempre n - 1, poderemos colocar o número do array, que é aulas.Length e - 1, garantindo que estamos sempre acessando a última posição do array. O código ficará assim, portanto:

aulas[aulas.Length - 1] = "Conclusão";
Imprimir(aulas);
Vamos rodar a aplicação e verificar seu funcionamento. Agora sim, conseguimos preencher a última posição com a string "Conclusão".

Para ordenarmos este array alfabeticamente, poderíamos utilizar o método estático da classe Array "Ordenar", que em inglês é "Sort", a partir do qual passaremos nosso array, imprimindo-o em seguida.

Array.Sort(aulas);
Imprimir(aulas);
Rodando o código, desta vez teremos as aulas em ordem alfabética, como gostaríamos:

Conclusão
Modelando a Classe Aula
Trabalhando com Arrays

 . O método Sort() não pode ser revertido, porque não é idempotente como o Reverse().

 . Para copiarmos um array a outro, criaremos um de destino, acrescentando seu novo
 tamanho, 2 (duas posições). Queremos duplicar as duas últimas aulas do nosso array
 de aulas para esta cópia.

 . Acessaremos o método estático da classe Array "cópia" (em inglês, "Copy"), 
 passando o array de origem (aulas), o índice inicial a partir do qual copiaremos
 o array de aulas (1, que equivale à segunda posição), o nome do array de destino,
 a posição inicial (índice 0), e a quantidade de elementos que iremos copiar (2):

string[] copia = new string[2];
Array.Copy(aulas, 1, copia, 0, 2);
Imprimir(copia);

 . Rodaremos a aplicação e veremos que copiamos as duas últimas aulas. Para fazer 
 o mesmo com todos os elementos, do início ao fim, poderíamos optar por uma maneira
 mais simples utilizando um método de clonagem.

 . Declararemos um novo array denominado clone. E, em vez de declararmos uma nova
 string, colocaremos a referência do nosso array inicial (aulas) chamando um 
 método muito conveniente: Clone.

string[] clone = aulas.Clone();

 . Porém o Visual Studio está "reclamando" por não conseguir converter o tipo object
 para string[], então teremos que fazer um cast:

string[] clone = aulas.Clone() as string[];
Imprimir(copia);

 . Rodaremos a aplicação e obteremos o resultado do nosso array clonado, que é 
 exatamente o nosso original aulas. Para terminar, veremos como limpar alguns 
 elementos do array clone, neste caso, os dois últimos.

 . Acessaremos o método estático da classe Array, de limpeza, do inglês clear, 
 bem como o índice da segunda posição (1) e o número de elementos que queremos 
 limpar (2), não esquecendo de imprimir este array clone:

Array.Clear(clone, 1, 2);
Imprimir(clone);

 . Feito isto, rodaremos o código e veremos que conseguimos limpar os dois últimos 
 elementos deste array. Se colocarmos um breakpoint na linha de código que acabamos
 de criar e rodarmos novamente a aplicação, confirmaremos isso.

 . Ao inspecionarmos o array, veremos que o primeiro elemento permanece intacto 
 (índice 0, "Conclusão"), e os outros dois passaram a ter valor nulo.

 . É importante lembrarmos que o array é um tipo muito básico de coleção do .NET,
 então o utilizaremos em casos específicos, como em transferências de arquivos, 
 manipulação de buffer ou imagens, em arquivos de baixo nível. Isso porque 
 normalmente, embora faça parte de várias coleções do .NET, o array não é tão 
 usado quanto outro tipo de coleção (como o List). Assim sendo, se for usar um 
 tipo de coleção, busque sempre ver se é possível optar pela lista no lugar de 
 um array, pois ela fornece métodos muito mais convenientes do que um simples array.


 //--------------------------------------------------------------------
 //--------------------------------------------------------------------
 //--------------------------------------------------------------------

	* 02 - Aula 01 - Introdução às Listas

 . Faremos algo muito parecido com o que fizemos na aula de arrays, porém utilizando
 outro tipo de coleção do .NET Framework, a Lista. Começaremos colando o código 
 inicial dessa aula, com aquelas três strings usadas na criação da primeira coleção.

 . A forma de declarar uma lista é bem diferente de um array. Primeiro colocamos o 
 nome da classe List, em seguida o tipo do elemento que ela irá conter, entre os 
 símbolos de <string>. A instância segue o mesmo padrão new List<string>. Assim, 
 teremos a primeira declaração de uma coleção Lista no nosso código, podemos iniciá-la
 com as string's que já deixamos preparada. Vamos imprimi-la e rodar a aplicação.

static void Main(string[] args)
{
    string aulaIntro = "Introdução às Coleções";
    string aulaModelando = "Modelando a Classe Aula";
    string aulaSets = "Trabalhando com Conjuntos";

    List<string> aulas = new List<string>
    {
        aulaIntro,
        aulaModelando,
        aulaSets
    };

    Console.WriteLine(aulas);
}
Na impressão, obtereremos o seguinte:

System.Collections.Generic.List`1[System.String]

 . Não temos a listagem de elementos pois, como vimos com os arrays, com 
 Console.WriteLine(), o nome da classe será pego no método do string, e não seu 
 conteúdo. Os elementos da lista de strings serão exibidos.

 . Precisaremos imprimir cada um dos elementos individualmente, extraindo o método 
 Console.WriteLine(), optando pelo uso de um laço.

static void Main(string[] args)
{
    string aulaIntro = "Introdução às Coleções";
    string aulaModelando = "Modelando a Classe Aula";
    string aulaSets = "Trabalhando com Conjuntos";

    List<string> aulas = new List<string>
    {
        aulaIntro,
        aulaModelando,
        aulaSets
    };
    Imprimir(aulas);
}

private static void Imprimir(List<string> aulas)
{
    foreach (var aula in aulas)
    {
        Console.WriteLine(aula);
    }
}

 . Feito isso, rodaremos a app e obteremos a impressão das três aulas:

Introdução às Coleções
Modelando a Classe Aula
Trabalhando com Conjuntos

 . Poderemos obter a declaração de aulas de outra forma, pois neste caso já conhecemos
 os elementos iniciais da nossa lista. No entanto, pode ser que não conheçamos. 
 Deixaremos o código assim:

static void Main(string[] args)
{
    string aulaIntro = "Introdução às Coleções";
    string aulaModelando = "Modelando a Classe Aula";
    string aulaSets = "Trabalhando com Conjuntos";

    //List<string> aulas = new List<string>
    //{
    //    aulaIntro,
    //    aulaModelando,
    //    aulaSets
    //};

    List<string> aulas = new List<string>();

    Imprimir(aulas);
}

private static void Imprimir(List<string> aulas)
{
    foreach (var aula in aulas)
    {
        Console.WriteLine(aula);
    }
}

 . Investigaremos o conteúdo da lista colocando um breakpoint no momento da impressão 
 de aulas. Quando colocamos a lupa em cima dela, veremos que a lista de aulas possui 
 uma quantidade 0 de elementos, ou seja, está vazia.

 . Vimos uma lista com 3 elementos e depois uma com nenhum elemento. Uma lista contém
 internamente um array, sendo assim chamada também de array dinâmico por "se acomodar"
 conforme a quantidade de elementos contidos.

 . Caso se trabalhe com um array com 10 elementos, é possível eliminar alguns, porém 
 suas posições ficam vazias (nulas). No caso de uma lista, isto não acontece; 
 conforme o acréscimo ou eliminação de elementos, a lista vai expandindo ou reduzindo.

 . Já declaramos a lista, vazia, então adicionaremos cada um dos elementos 
 necessários, o que significa que isso pode ser feito aos poucos, sem a declaração 
 dos elementos iniciais:

List<string> aulas = new List<string>();
aulas[0] = aulaIntro;

Imprimir(aulas);

 . Ao rodarmos a aplicação, teremos um erro! Um 
 System.ArgumentOutOfRangeException ("O índice estava fora do intervalo. 
 Ele deve ser não-negativo e menor que o tamanho da coleção"). O que acontece 
 é que estamos acessando o índice, mas ele é inexistente na lista, pois está vazia.
 É necessário fazermos isto de outra forma.

 . Em se tratando de listas, não a atribuímos desta maneira para acrescentarmos 
 elementos. Para isto, na variável de aulas, acessaremos o método de adicionar Add():

List<string> aulas = new List<string>();
aulas.Add(aulaIntro);
aulas.Add(aulaModelando);
aulas.Add(AulaSets);

Imprimir(aulas);

 . Rodaremos a app de novo para vermos o resultado... Muito bem, conseguimos enxergar
 os três elementos adicionados! Faremos uma modificação no método Imprimir(), por 
 conta do laço foreach, feito com base em uma lista. Poderemos usar o for, assim 
 como fizemos com o array.

 . Varreremos a lista a partir do índice 0 até a quantidade total de seus elementos
 e acessaremos a variável aulas e a propriedade length. No entanto, quando digitamos,
 esta palavra não é encontrada, pois não faz parte do objeto List<string>. 
 Utilizaremos Count em seu lugar, que é seu equivalente no uso de listas:

private static void Imprimir(List<string> aulas)
{
    //foreach (var aula in aulas)
    //{
    //    Console.WriteLine(aula);
    //}

    for (int i = 0; i < aulas.Count; i++)
    {
        Console.WriteLine(aulas[i]);
    }
}

 . Rodaremos e imprimiremos mais uma vez, e tudo ocorrerá sem problemas. Há ainda 
 uma terceira forma de fazermos isso: em vez de utilizarmos uma instrução como 
 foreach ou for, usaremos um método (ForEach()).

private static void Imprimir(List<string> aulas)
{
    //foreach (var aula in aulas)
    //{
    //    Console.WriteLine(aula);
    //}

    //for (int i = 0; i < aulas.Count; i++)
    //{
    //    Console.WriteLine(aulas[i]);
    //}

    aulas.ForEach(aula => 
    {
        Console.WriteLine(aula);
    });
}

 . Rodaremos o código para verificar se o resultado é o mesmo, o que se confirma. 
 Neste momento, acessaremos o primeiro elemento das aulas, o que significa imprimir 
 a primeira aula. Colocaremos um Console.WriteLine("A primeira aula é " + aula[0]);.

List<string> aulas = new List<string>();
aulas.Add(aulaIntro);
aulas.Add(aulaModelando);
aulas.Add(AulaSets);

Imprimir(aulas);

Console.WriteLine("A primeira aula é " + aulas[0]);
Rodando a aplicação, teremos o resultado:

A primeira aula é Introdução às Coleções
 
 . Caso queiramos a última aula, copiaremos a linha que acabamos de criar, 
 trocaremos "primeira" por "última" e, no lugar do índice 0, colocaremos o 
 último índice que, como vimos anteriormente, será aulas.Count - 1:

Console.WriteLine("A primeira aula é " + aulas[0]);
Console.WriteLine("A última aula é " + aulas[aulas.Count - 1]);

 . Rodando a app novamente, teremos:

A última aula é Trabalhando com Conjuntos

 . Outra maneira de acessarmos estes elementos - o último e o primeiro - se dá 
 por meio de Last e First ("último" e "primeiro" em inglês), respectivamente:

Console.WriteLine("A primeira aula é " + aulas.First());
Console.WriteLine("A última aula é " + aulas.Last());
Rodaremos o código para confirmar esta alteração.

 . Neste vídeo, vimos alguns métodos interessantes da classe List, declarando-a 
 de modos diferentes. E também aprendemos a visualizar impressões pelo método 
 ForEach().

  //--------------------------------------------------------------------
  
	* 02 - Aula 02 - Operações com Listas

 . Desta vez queremos trocar o nome da primeira aula acessando a lista de aulas e 
 a primeira posição, de índice 0. Atribuiremos a ela um novo valor string.

Console.WriteLine("A última aula é " + aulas[aulas.Count - 1]);
Console.WriteLine("A última aula é " + aulas.Last());

aulas[0] = "Trabalhando com Listas";
Imprimir(aulas);

 . Rodaremos a aplicação e verificaremos que a alteração foi feita corretamente.

 . Para exemplificarmos uma busca por determinada palavra nesta lista, pesquisaremos
 pela primeira que contiver a palavra "trabalhando". Já vimos que First() retornará 
 o primeiro elemento independentemente do conteúdo. No entanto, este método possui 
 sobrecarga ("overload"), o que é bastante útil.

 . Existe a opção de passarmos um parâmetro para First(), um predicado possível de 
 ser utilizado por meio de uma expressão lambda, a qual define, neste caso, uma 
 função anônima. Utilizaremos também o método Contains(), que trará true ou false 
 dependendo do resultado da busca.

Console.WriteLine("A primeira aula 'Trabalhando' é:" + aulas.First(aula => 
aula.Contains("Trabalhando")));

Vamos rodar a aplicação. Obteremos o seguinte:

 . A primeira aula 'Trabalhando' é: Trabalhando com Listas

 . Faremos algo parecido para buscarmos a última aula. Copiaremos as linhas de código 
 recém criadas e substituiremos "primeira" por "última" e "First" por "Last":

 . Console.WriteLine("A primeira aula 'Trabalhando' é:" + aulas.First(aula =>  
 aula.Contains("Trabalhando")));

 . Console.WriteLine("A última aula 'Trabalhando' é:" + aulas.Last(aula =>  
 aula.Contains("Trabalhando")));

Feito isto, obteremos a mensagem:

 A última aula 'Trabalhando' é: Trabalhando com Conjuntos

 . Para buscarmos a palavra "Conclusão", copiaremos e colaremos o código novamente,
 trocando "Trabalhando" por "Conclusão":

Console.WriteLine("A primeira aula 'Trabalhando' é:" + aulas.First(aula =>  aula.Contains("Trabalhando")));

Console.WriteLine("A última aula 'Trabalhando' é:" + aulas.Last(aula =>  aula.Contains("Trabalhando")));

Console.WriteLine("A primeira aula 'Conclusão' é:" + aulas.First(aula =>  aula.Contains("Conclusão")));

 . Obteremos um erro de InvalidOperationException: "A sequência não contém elementos 
 de correspondência". Muito cuidado quando for fazer uma busca deste tipo, cujo
 resultado não é encontrado, pois será necessário estar preparado para tratar este 
 tipo de situação.

 . Neste caso, em vez de First(), usaremos um método similar, FirstOrDefault(), o 
 qual retorna o primeiro elemento de uma sequência ou valor default, se a sequência
 não contém elementos. Ou seja, quando nada é encontrado, o valor será substituído 
 por um "null", ou "nulo".

Console.WriteLine("A primeira aula 'Conclusão' é:" + aulas.FirstOrDefault(aula =>  aula.Contains("Conclusão")));
Ao rodarmos este novo código, nenhum erro aparece, e sim o seguinte texto:

A primeira aula 'Conclusão' é:

 . Se quisermos reverter esta lista para trocarmos sua ordem, assim como fizemos 
 com os arrays, utilizaremos aulas.Reverse(); sem termos que acessar o método da 
 classe Array como fazíamos anteriormente. A reversão é feita diretamente no objeto
 aulas.

aulas.Reverse();
Imprimir(aulas);

 . Teremos o que queríamos e, para voltarmos ao estado inicial, basta copiarmos e 
 colarmos estas mesmas linhas.

 . Assim como fizemos com os arrays, que tal removermos o último elemento da lista?
 Acessaremos o objeto aulas e usaremos o método Remove(), que nos traz outras opções,
 como RemoveAt() (remoção de uma parte específica), para o qual também precisaremos 
 passar o índice desejado.

 . Neste caso, precisaremos saber o tamanho da nossa lista por meio de aulas.Count, 
 imprimindo-a em seguida:

aulas.RemoveAt(aulas.Count - 1);
Imprimir(aulas);
Obteremos:

Trabalhando com Listas
Modelando a Classe Aula
O "Trabalhando com Conjuntos" sumiu, pois foi removido. Temos dois elementos, diferentemente de um array, cuja remoção do último elemento se dá pelo Resize() e, ao redimensionarmos de volta, a lista fica com valor nulo.

 . Aqui, quando removemos elementos, a lista vai diminuindo e expandindo, conforme 
 se vai adicionando ou removendo itens. Para acrescentarmos mais uma aula à nossa 
 lista, poderemos utilizar o método Add():

aulas.Add("Conclusão");
Imprimir(aulas);

 . Para ordenar a lista de forma alfabética, precisaremos do método Sort(), como 
 visto com arrays, porém sem o método estático na classe List, acessando-se 
 diretamente pelo objeto aulas:

aulas.Sort();
Imprimir(aulas);

 . Para copiarmos os dois últimos elementos da lista de aulas, escreveremos o 
 seguinte código:

List<string> copia = aulas.GetRange(aulas.Count - 2, 2)
Imprimir(copia);

 . Agora faremos o equivalente à clonagem do array. Aqui, não temos um método para
 isto. Declararemos a lista denominada clone, uma nova lista, não mais do tipo string.
 Simplesmente obteremos uma lista a partir da nossa lista original, acessando um 
 construtor diferente, já que o padrão não possui parâmetros.

 . Há outra variação, com capacidade (o tamanho) da lista inicial, que também não 
 nos interessa. A terceira variação do construtor recebe uma coleção possível de ser 
 nossa lista original:

List<string> clone = new List<string>(aulas);
Imprimir(clone);

 . Com isto, instanciaremos nosso clone a partir dos elementos contidos em aulas e 
 teremos sua cópia exata.

 . Para finalizar, removeremos os dois últimos elementos do nosso clone, 
 mencionando-o e escolhendo a opção RemoveRange (remover uma faixa de elementos), 
 passando o índice da primeira posição que queremos remover como primeiro parâmetro e, 
 como segundo, a quantidade que queremos remover, que é 2.

clone.RemoveRange(clone.Count - 2, 2);
Imprimir(clone);

 . Como critério para o desenvolvimento de uma aplicação, sempre que pensar em 
 coleções, pense primeiro em listas, partindo para outro tipo de coleção apenas 
 se ela não for o suficiente.
  
  //--------------------------------------------------------------------

	* 02 - Aula 03 - Listas de Objetos

	Neste vídeo estamos trabalhando com um novo projeto, um Console Application, e veremos as três strings do vídeo anterior, aquelas três aulas:

namespace A23ListasDeObjetos
{
    class Program
    {
        static void Main(string[] args)
        {
            string aulaIntro = "Introdução às Coleções";
            string aulaModelando = "Modelando a Classe Aula";
            string aulaSets = "Trabalhando com Conjuntos";
        }
    }
}
Além destes nomes (as strings), precisaremos trabalhar com a duração destas aulas, uma lista que as armazene. Trata-se de uma lista de objetos do tipo Aula. Vamos declarar a classe:

class Aula
{
    private string titulo;
    private int tempo;
}
A partir destes dois campos, criaremos propriedades com o atalho "Ctrl + . [ponto]", selecionando "Encapsular campo: 'titulo'" para o Visual Studio gerar uma propriedade homônima. Faremos o mesmo para tempo.

Feito isto, selecionaremos os dois campos, titulo e tempo, clicando em "Ctrl + ." e selecionando "Gerar construtor 'Aula(string, int)'".

class Aula
{
    private string titulo;
    private int tempo;

    public Aula(string titulo, int tempo)
    {
        this.titulo = titulo;
        this.tempo = tempo;
    }

    public string Titulo { get => titulo; set => titulo = value; }
    public int Tempo { get => tempo; set => tempo = value; }
}
Trocaremos as strings por instâncias da classe Aula, substituindo todas elas por var, passando também o tempo de duração de cada aula em minutos.

Criaremos também a instância da nossa listagem utilizando List, uma classe genérica de tipo Aula. Declararemos a variável aulas, que armazenará a lista com todas as aulas declaradas anteriormente.

Supondo que queiramos acrescentar mais uma aula ("Conclusão") em nossa lista, desta vez uma string, digitaremos:

static void Main(string[] args)
  {
    var aulaIntro = new Aula("Introdução às Coleções", 20);
    var aulaModelando = new Aula("Modelando a Classe Aula", 18);
    var aulaSets = new Aula("Trabalhando com Conjuntos", 16);

    List<Aula> aulas = new List<Aula>();
    aulas.Add(aulaIntro);
    aulas.Add(aulaModelando);
    aulas.Add(aulaSets);
    aulas.Add("Conclusão");
  }
Porém, ao fazermos isto, o Visual Studio nos informa que não é possível converter uma string para uma instância da classe Aula. Quando se define uma lista como sendo de um determinado tipo, só é possível adicionar elementos cujo tipo seja daquela instância, a menos que seja uma herança - ou derivada - daquele tipo utilizado como elemento.

Portanto, por ora, comentaremos esta linha. Continuando, para imprimirmos chamaremos um método, passando como argumento a nossa lista de aulas. Como Imprimir() ainda não existe, solicitaremos ao Visual Studio a criação deste método.

static void Main(string[] args)
  {
    var aulaIntro = new Aula("Introdução às Coleções", 20);
    var aulaModelando = new Aula("Modelando a Classe Aula", 18);
    var aulaSets = new Aula("Trabalhando com Conjuntos", 16);

    List<Aula> aulas = new List<Aula>();
    aulas.Add(aulaIntro);
    aulas.Add(aulaModelando);
    aulas.Add(aulaSets);
    //aulas.Add("Conclusão");

    Imprimir(aulas);
  }

private static void Imprimir(List<Aula> aulas)
{
    Console.Clear();
    foreach (var aula in aulas)
    {
        Console.WriteLine(aula);
    }
}
Com "Ctrl + F5", rodaremos a aplicação. Obteremos não os nomes das aulas, e sim três linhas contendo o namespace do objeto Aula. Não é o que gostaríamos! Isso ocorre porque quando pedimos a impressão, o Console.WriteLine() vai até o objeto Aula, em busca de um método chamado ToString(), inexistente na classe Aula.

No entanto, como a classe Aula naturalmente herda da classe Object, o método ToString() é buscado na classe Object, que é de onde vem a impressão final, o resultado. Precisaremos sobrepor este método da classe Object para que se imprima aquilo que queremos.

Para realizar este override, implementaremos um método ToString() na classe Aula. Digitando override e dando espaço, obtém-se a opção ToString. Clicando nele, o programa já nos cria este método.

Para concatenarmos as informações provenientes da classe Aula, utilizaremos a sintaxe interpolação de strings, que faz parte do C#, marcada pelo uso de $ e chaves ({}).

public override string ToString()
{
    return $"[título: {titulo}, tempo: {tempo} minutos]";
}
Rodaremos a aplicação novamente, e obteremos o seguinte:

[título: Introdução às Coleções, tempo: 20 minutos]
[título: Modelando a Classe Aula, tempo: 18 minutos]
[título: Trabalhando com Conjuntos, tempo: 16 minutos]
Prosseguindo, faremos outra operação com a listagem de aulas, a ordenação alfabética. Para isso, chamaremos o método Sort() pois, como vimos anteriormente, serve bem para este propósito.

aulas.Sort();
Imprimir(aulas);
Rodando a aplicação, teremos um erro, de falha ao comparar dois elementos na matriz, pois pelo menos um deles deve implementar IComparable. Isto significa que a classe Aula não está implementando a interface necessária para realizar esta operação, que exige uma interface chamada IComparable.

Clicando em cima disto e apertando "Ctrl + .", a interface é de fato implementada.

class Aula : IComparable
{
    //...
}
O método CompareTo() foi gerado para comparar dois elementos que fazem parte da classe Aula, uma vez que o método Sort() precisa chamar CompareTo() para saber que algoritmo precisará ser usado para a ordenação.

Acrescentaremos um return para que o título seja comparado com o nome do outro objeto, o parâmetro object obj. O CompareTo() recebe como parâmetro este objeto da classe Aula, e poderíamos passar obj chamando obj.titulo.

No entanto, isto não existe, pois object é um objeto, sendo necessário, então, fazermos um cast, uma conversão para que isso possa ser trabalhado.

O código ficará assim:

public int CompareTo(object obj)
{
    Aula that = obj as Aula;
    return this.titulo.CompareTo(that.titulo);
}
Vamos rodar a aplicação de novo para verificar se tudo funciona corretamente. Muito bem, as aulas aparecem listadas em ordem alfabética.

Agora, de que forma poderemos, sem que a classe Aulas seja alterada, mudar a forma de ordenação? Ordenando-se não pelo título, mas pelo tempo de duração, por exemplo? Ao tentarmos utilizar o método Sort() verificaremos que há um overload, que pode receber parâmetros.

É possível, assim, compararmos dois elementos ou instâncias de uma mesma classe. No método Sort(), usaremos uma expressão lambda, a receber dois parâmetros, elementos iniciais e finais, com nomes que você quiser, como este e outro.

Iremos usar CompareTo() mais uma vez, para compararmos este com outro:

aulas.Sort();
Imprimir(aulas);

aulas.Sort((este, outro) => este.Tempo.CompareTo(outro.Tempo));
Imprimir(aulas);
Rodaremos o código e veremos que a listagem de aulas foi ordenada do menor para o maior tempo de duração com sucesso!

	 
 //--------------------------------------------------------------------
  
  * 2 - Aula 05 - Lista Somente Leitura

  Para este vídeo criamos um novo projeto Console Application, mantendo a classe Aula, contida em um arquivo separado (Aula.cs). Em Program.cs, mantivemos nosso método Imprimir():

private static void Imprimir(List<Aula> aulas)
{
    Console.Clear();
    foreach (var aula in aulas)
    {
        Console.WriteLine(aula);
    }
}
Neste vídeo aumentaremos um pouco mais a arquitetura para criarmos uma nova classe com os cursos cujas aulas serão incluídas.

Esta classe se chamará Curso.cs e terá três propriedades: a lista de aulas (como visto anteriormente), o nome do curso e instrutor.

Utilizaremos o atalho "propfull + TAB + TAB" para criar a estrutura da propriedade necessária, com get e set. Declararemos seu tipo, e a propriedade será pública, denominada Aulas. Faremos o mesmo para o nome do curso e instrutor.

namespace A24ListaSomenteLeitura
{
    class Curso
    {
        private List<Aula> aulas;

        public List<Aula> Aulas
        {
            get { return aulas; }
            set { aulas = value; }
        }

        private string nome;

        public string Nome
        {
            get { return nome; }
            set { nome = value; }
        }

        private string instrutor;

        public string Instrutor
        {
            get { return instrutor; }
            set { instrutor = value; }
        }
    }
}
Criaremos também o construtor da classe recém criada. Para fazê-lo de maneira mais prática, usando as teclas "Alt + seta para cima", deixaremos a linha private string instrutor; logo abaixo de private string nome;.

Então selecionaremos estas duas linhas para que o construtor seja gerado. Com "Ctrl + ." clicaremos em Generate constructor 'Curso(string, string)', no qual instanciaremos a lista de aulas, pois inicialmente ela estará nula.

Inicialmente, definiremos esta lista como nova, a qual, a partir de agora, poderemos acessar sem problema algum em relação à referência nula.

private string nome;
private string instrutor;

public Curso(string nome, string instrutor)
{
    this.nome = nome;
    this.instrutor = instrutor;
    this.aulas = new List<Aula>();
}
Voltando a Program.cs, declararemos uma variável Curso de nome csharpColecoes, pelo qual acessaremos a propriedade pública Aulas. Adicionaremos uma nova aula a esta lista com o método Add(), passando como parâmetro uma nova instância da classe Aula.

static void Main(string[] args)
{
    Curso csharpColecoes = new Curso("C# Collections", "Marcelo Oliveira");
    csharpColecoes.Aulas.Add(new Aula("Trabalhando com Listas", 21));
    Imprimir(csharpColecoes.Aulas);
}
Imprimiremos o resultado no console e rodaremos a aplicação com "Ctrl + F5". Obteremos o seguinte:

[título: Trabalhando com Listas, tempo: 21 minutos]
Conseguimos criar a classe Curso com sucesso, populando e imprimindo as aulas. No entanto, há um problema não muito evidente, conhecido por code smell na programação, ou "mau cheiro no código", que neste caso implica no fato de acessarmos csharpColecoes.Aulas e a lista de aulas da classe Curso adicionando elementos nela.

Isso significa que estamos "passando por cima" da responsabilidade da classe Curso de manter suas propriedades, e estamos manipulando diretamente esta lista de aulas.

O correto seria chamarmos um método da classe Curso para podermos adicionar estes elementos. Caso contrário, esta classe não tem nenhum controle sobre as suas aulas, pois esta listagem está exposta.

Trata-se de um code smell por ser uma "exposição indecente". Para evitarmos que uma propriedade fique exposta à manipulações externas, é necessário encapsularmos esta funcionalidade de adicionar elementos na lista.

Então, primeiramente, teremos que bloquear esta lista interna para evitar a possibilidade de manipulação por código externo. Acessando-se a classe Curso, modificaremos a propriedade Aulas, em que encontramos get e set.

Removeremos o set, pois do jeito que está, qualquer um pode alterá-lo para um valor nulo, e a classe Curso perde qualquer chance de barrar esta modificação. Feito isso, retornaremos não mais uma lista de aulas (List<Aula>) em get, mas outro tipo de objeto, uma coleção somente leitura (read only collection).

ReadOnlyCollection se localiza no .NET com namespace System.Collections.ObjectModel, e é uma classe genérica, portanto necessita também do tipo de elemento (no caso, a classe Aula). Precisaremos passar no construtor um parâmetro que é uma lista, a própria referência das aulas.

Aulas é o campo privado que está sendo protegido, porém o Visual Studio não consegue converter ReadOnlyCollection para um List<Aula>, declarado na propriedade. Portanto, precisaremos trocá-lo por um IList<Aula>, que é o que o ReadOnlyCollection implementa. O código ficará desta forma:

class Curso
{
    private IList<Aula> aulas;

    public IList<Aula> Aulas
    {
        get { return new ReadOnlyCollection<Aula>(aulas); }
    }
}
Veremos outro problema, desta vez na hora de chamarmos o método Imprimir(), pois estamos passando uma propriedade de tipo IList<>, e nosso método recebe List<>. Precisaremos fazer a devida alteração.

Feito isso, rodaremos a aplicação! Há um erro: System.NotSupportedException "Coleção é somente leitura". Protegemos nossa coleção para que ela fosse somente leitura, e assim, o código externo fica impedido de modificar esta coleção.

É preciso encapsularmos esta funcionalidade de adicionar algum elemento na lista de aulas em algum método da classe Curso, porque aí sim, ela terá o poder de controlar esta funcionalidade.

Para facilitar, como temos csharpColecoes.Aulas.Add(), poderemos trocar por csharpColecoes.Adiciona(). No entanto, este novo método ainda não existe. Com "Ctrl + .", clicaremos no atalho Generate method 'Curso.Adiciona'.

Com F12, entraremos no método para o implementarmos:

internal void Adiciona (Aula aula)
{
    this.aulas.Add(aula);
}
Rodando novamente a aplicação, teremos:

[título: Trabalhando com Listas, tempo: 21 minutos]

  //--------------------------------------------------------------------

	* 2 - Aula 07 - Ordenando e Totalizando

	No último vídeo aprendemos a proteger a coleção de aulas do curso, modificando o retorno como sendo de coleção somente leitura, ou read only collection. O que faremos agora são algumas operações em cima desta lista de aulas.

Inicialmente, adicionaremos duas aulas novas neste curso:

static void Main(string[] args)
{
    Curso csharpColecoes = new Curso("C# Collections", "Marcelo Oliveira");
    csharpColecoes.Aulas.Add(new Aula("Trabalhando com Listas", 21));
    Imprimir(csharpColecoes.Aulas);

    //adicionar 2 aulas
    csharpColecoes.Adiciona(new Aula("Criando uma Aula", 20));
    csharpColecoes.Adiciona(new Aula("Modelando com Coleções", 19));

    //imprimir
    Imprimir(csharpColecoes.Aulas);
}
Rodaremos com "Ctrl + F5" e obteremos como resultado:

[título: Trabalhando com Listas, tempo: 21 minutos]
[título: Criando uma Aula, tempo: 20 minutos]
[título: Modelando com Coleções, tempo: 19 minutos]
Em seguida, colocaremos estas aulas em ordem alfabética:

static void Main(string[] args)
{
    Curso csharpColecoes = new Curso("C# Collections", "Marcelo Oliveira");
    csharpColecoes.Aulas.Add(new Aula("Trabalhando com Listas", 21));
    Imprimir(csharpColecoes.Aulas);

    //adicionar 2 aulas
    csharpColecoes.Adiciona(new Aula("Criando uma Aula", 20));
    csharpColecoes.Adiciona(new Aula("Modelando com Coleções", 19));

    //imprimir
    Imprimir(csharpColecoes.Aulas);

    //ordenar a lista de aulas
    csharpColecoes.Aulas.Sort();
}
Ao rodarmos o código acima, ocorre um erro que indica que IList<Aula> não contém a definição para Sort(), pois quando vamos à definição de csharpColecoes.Aulas com a tecla F12, veremos que ela foi declarada como um IList<>, interface que não dá suporte ao método de ordenação.

Em Program.cs, tentaremos ordenar de outra maneira, copiando a lista para outra, por exemplo. Só que desta vez não usaremos uma lista somente leitura, e sim alguma que permita, além da ordenação, outros tipos de modificação.

Esta definição de aulas copiadas irá trazer uma lista vazia, e não é isto que queremos. Queremos instanciar uma lista com todas as aulas existentes no curso. Para criar uma lista previamente populada com estas aulas, passaremos a listagem no construtor. Feito isso, poderemos ordená-la propriamente:

//ordenar a lista de aulas
//csharpColecoes.Aulas.Sort();

//copiar a lista para outra lista
List<Aula> aulasCopiadas = new List<Aula>(csharpColecoes.Aulas);

//ordenar a cópia
aulasCopiadas.Sort();

Imprimir(aulasCopiadas);
Rodaremos com "Ctrl + F5" e veremos que tudo foi feito como gostaríamos. A próxima tarefa será totalizar o tempo do curso. Em Curso.cs, acrescentaremos o seguinte:

public string Instrutor
{
    get { return instrutor; }
    set { instrutor = value; }
}

public int TempoTotal
{
    get
    {
        int total = 0;
        foreach (var aula in aulas)
        {
            total += aula.Tempo;
        }
        return total;
    }
}
E em Program.cs teremos:

//totalizar o tempo do curso
Console.WriteLine(csharpColecoes.TempoTotal);
Rodando a aplicação, o resultado da soma é 60, como total do curso. Poderemos consegui-lo de outra forma: há um conjunto de técnicas chamado LINQ, criado pela Microsoft como um conjunto de extensões que dá suporte a uma série de consultas que podem ser feitas em cima de coleções, possibilitando também o trabalho com banco de dados, XML, e outros.

O que fazemos com nosso acumulador para totalizar o tempo do curso, na verdade, é uma consulta, que pode ser feita de modo completamente diverso, mais simples e elegante.

O método Sum() exige que passemos um seletor, uma expressão lambda e a propriedade da aula que nos interessa, Tempo. Em Curso.cs, então:

get
{
    //int total = 0;
    //foreach (var aula in aulas)
    //{
    //  total += aula.Tempo;
    //}
    //return total;

    //LINQ = Language Integrated Query
    //Consulta Integrada à Linguagem

    return aulas.Sum(aula => aula.Tempo);
}
Voltaremos a Program.cs e rodaremos novamente para confirmar o mesmo resultado que já tínhamos (60). Para finalizar, imprimiremos este curso, acrescentando a variável csharpColecoes:

//totalizar o tempo do curso
Console.WriteLine(csharpColecoes.TempoTotal);

Console.WriteLine(csharpColecoes);
Rodando, teremos como resultado o namespace A25OrdenandoESomando.Curso, porém queremos o nome, duração e demais especificidades do curso. Neste caso, teremos que implementar um método, o ToString().

Quando imprimimos um objeto qualquer que ainda não implementou esta propriedade, chamamos o método ToString() do Object do .NET, que imprimirá o namespace e o nome da classe.

Utilizaremos override, uma operação de sobrescrita de um método cuja classe base já existe (no caso, Object). Para as aulas, usaremos o string.Join juntará as strings da coleção, separando-as por vírgulas. Teremos:

public override string ToString()
{
    return $"Curso: {nome}, Tempo: {TempoTotal}, Aulas: {string.Join(",", aulas)}";
}
Em Program.cs, rodaremos novamente a aplicação. O resultado é:

Curso: C# Collections, Tempo: 60, Aulas: [título: Trabalhando com Listas, tempo: 21 minutos],[título: Criando uma Aula, tempo: 20 minutos],[título: Modelando com Coleções, tempo: 19 minutos]
Conseguimos o que gostaríamos!

  //--------------------------------------------------------------------

	* 2 - Aula 09 - Mão na massa

	Começando deste ponto? Você pode fazer o DOWNLOAD completo do projeto do capítulo anterior e continuar seus estudos a partir deste capítulo.

Vamos botar a mão na massa mais uma vez, desta vez para trabalhar com o tipo de coleção mais poderosa e flexível .NET Framework: a classe List<T>, também conhecida como array dinâmico.

Declarando uma lista
Lembra daquelas 3 variáveis de strings da última aula? Vamos usá-las novamente:

string aulaIntro = "Introdução às Coleções";
string aulaModelando = "Modelando a Classe Aula";
string aulaSets = "Trabalhando com Conjuntos";


Agora vamos declarar nossa lista.

A sintaxe de uma lista de strings em C
Diferente de um array, uma lista (List<T>) não possui uma sintaxe especial em C#. Na declaração, usamos a classe genérica List<T>, onde o tipo T especifica a natureza dos seus elementos.

Declarando e inicializando uma lista


Pode ser que você queira criar uma vazia. Mas também pode ser que você queira declarar E preencher de uma vez só. Nesse caso, usamos a sintaxe com as chaves {...} incluindo uma lista de itens iniciais.

List<string> aulas = new List<string>
{
    aulaIntro,
    aulaModelando,
    aulaSets
};
Inicializando uma lista vazia


Já uma lista vazia tem a sintaxe normal de uma declaração de objeto em C#:

List<string> aulas = new List<string>();
A lista como um array dinâmico
Como assim, array dinâmico?

Simples: um array é uma coleção de tamanho fixo, com número estático de elementos, certo?

Então a lista (List<T>) é parecida, só que quando você adiciona/remove elementos dela, o tamanho da lista aumenta ou diminui, respectivamente.

E é por isso mesmo que podemos iniciar uma lista vazia, com tamanho zero, adicionando elementos posteriormente conforme desejado.

Adicionando elementos


O jeito mais fácil de alimentar uma lista é adicionando elementos. E isso fazemos com o método Add(), que significa "adicionar" em inglês.

aulas.Add(aulaIntro);
aulas.Add(aulaModelando);
aulas.Add(aulaSets);
Com esse método, um elemento é sempre adicionado ao final da lista.

Ou seja, a lista funciona como uma sequência.

Imprimindo listas
Lembra de quando tentamos imprimir um array no console?

Que tal fazer o mesmo com uma lista?

Console.WriteLine(aulas);
Como antes, esse código não imprime os elementos da lista individualmente. Em vez disso, ele só imprime o namespace seguido do nome da classe:

System.Collections.Generic.List`1[System.String]
Então, novamente, precisamos imprimir os elementos da lista um a um. Vamos criar o método Imprimir() para isso:

private static void Imprimir(List<string> aulas)
{
    foreach (var aula in aulas)
    {
        Console.WriteLine(aula);
    }

    Console.WriteLine();
}
O código acima utiliza um laço com a instrução foreach. Assim como com arrays, podemos também usar um laço com instrução for:

private static void Imprimir(List<string> aulas)
{
    for (int i = 0; i < aulas.Count; i++)
    {
        Console.WriteLine(aulas[i]);
    }
    Console.WriteLine();
}
Mas uma List<T> ainda possui mais uma maneira de varrer a coleção: o método ForEach():

private static void Imprimir(List<string> aulas)
{
    aulas.ForEach(aula => 
    {
        Console.WriteLine(aula);
    });
    Console.WriteLine();
}
O que esse método faz?

Ele recebe uma Action, que é um delegate, ou delegado, que encapsula um método que não retorna valor (método void).

Note que, acima, a Action é declarada como expressão lambda:

aula => 
{
    Console.WriteLine(aula);
}
Uma expressão lambda é uma função anônima (isto é, um método sem nome) que permite criar uma expressão inline, ou em linha, sem a necessidade de referenciar um método externo.

Uma expressão lambda contém três partes:

o parâmetro (aula)
o operador lambda (=>)
o corpo do método anônimo ({ Console.WriteLine(aula); })
Índices


Uma List<T> também possui indexador, e é por isso que podemos usar a sintaxe que vimos em arrays:

Console.WriteLine("A primeira aula é " + aulas[0]);
Note que a mesma sintaxe de índice pode ser usada tanto para ler quanto para modificar items:

aulas[0] = "Trabalhando com Listas";
Acessando elementos de uma lista
Para pegar o primeiro elemento da lista (posição 1, índice 0), basta acessar o índice adequado:

Console.WriteLine("A primeira aula é " + aulas[0]);
Mas também há um outro jeito de fazer isso, utilizando o método First():

Console.WriteLine("A primeira aula é " + aulas.First());
Note que o método First() não faz parte da classe List<T>: ele é fornecido pela extensão LINQ (Language INtegrated Queries, ou Consultas Integradas à Linguagem), que existe num namespace separado, o namespace System.Linq.

Mas não há muita diferença entre usar índice ou usar First para acessar o primeiro item, não é verdade? Mas o mesmo não podemos dizer quando queremos pegar o último elemento:

Na sintaxe de índice temos:

Console.WriteLine("A última aula é " + aulas[aulas.Count - 1]);
Já usando LINQ, o método Last() se torna bem mais legível!

Console.WriteLine("A última aula é " + aulas.Last());
Gostou do LINQ? Aprenda o que há por trás dessa tecnologia de consultas de coleções, fazendo nossos cursos LinQ parte 1 e LinQ parte 2 aqui na Alura!

Procurando elementos


Aproveitando um pouco mais das extensões do LINQ, vamos procurar agora algums elementos pelo seu conteúdo.

Encontrando a primeira ocorrência
"Qual é a primeira aula da lista que contém a palavra 'Trabalhando'"?

Pra responder essa pergunta vamos usar o método First() (lembra dele)?

aulas.First()
Mas desta vez, vamos utilizar uma sobrecarga, ou overload, ou seja, uma variação deste método, uma que aceita como parâmetro um predicate (predicado) que descreve qual condição deve ser satisfeita nessa busca.

aulas.First(aula => ...))
E acima, de novo, usamos expressão lambda... melhor você se acostumar com ela!

A condição é: que contém a palavra 'Trabalhando'.

Traduzindo isso para a nossa querida linguagem C#, fica assim:

aulas.First(aula => aula.Contains("Trabalhando"))
Colocando tudo junto, imprimimos o resultado no console:

Console.WriteLine("A primeira aula 'Trabalhando' é: "
    + aulas.First(aula => aula.Contains("Trabalhando")));
Encontrando a última ocorrência
E pra pegar a última aula da lista com a palavra "Trabalhando"?

Mesma coisa, só que usamos agora o método Last():

Console.WriteLine("A última aula 'Trabalhando' é: "
    + aulas.Last(aula => aula.Contains("Trabalhando")));
Mas há um problema nesses métodos: se nenhum elemento for encontrado, tomaremos um erro!

System.InvalidOperationException: 'A sequência não contém elementos de correspondência'
Então, nesse caso, podemos resolver o problema com um método similar, que devolve o valor default caso não haja ocorrências:

Console.WriteLine("A primeira aula 'Conclusão' é: "
    + aulas.FirstOrDefault(aula => aula.Contains("Conclusão")));
E o que seria, exatamente, esse valor default? Depende. Em um objeto ou string, seria um null. Em um decimal, double, etc. seria um zero. E assim por diante.

Revertendo lista


Para reverter a ordem de uma lista, usamos o método conhecido, Reverse:

aulas.Reverse();
Imprimir(aulas);
Mas qual a diferença para o método que usamos em arrays? Apenas o fato de que esse método não é estático.

E se quisermos voltar a lista para sua ordem original, basta executar o método novamente:

aulas.Reverse();
Imprimir(aulas);
Removendo um elemento


Podemos remover o elemento de uma lista pela sua posição.

Nesse caso, passando o índice desejado. Se é o último, então índice = aulas.Count - 1.

aulas.RemoveAt(aulas.Count - 1);
Imprimir(aulas);
Se você precisar remover uma região de uma lista, o caminho é o método RemoveRange.

Vamos mostrar um exemplo de remoção da última e penúltima aulas da lista:

aulas.RemoveRange(aulas.Count - 2, 2);
Imprimir(clone);
O método acima remove uma região (range) que começa no penúltimo elemento (aulas.Count - 2) e abrange 2 elementos.

Mas também podemos remover elemento pelo seu conteúdo. Se nossa lista é de strings, temos que passar uma string como parâmetro:

aulas.Remove("Conclusão");
Imprimir(aulas);
Lembre-se de que uma lista é uma coleção dinâmica! Perceba que todos esses métodos para remover elementos acabam afetando o tamanho da lista.

Ordenando lista


Listas podem ser ordenadas com o método Sort. Uma lista de strings será posta em ordem alfabética:

aulas.Sort();
Imprimir(aulas);
Mas o método Sort tem um outro overload ("sobrecarga") que recebe um IComparison (comparação), que que define o critério de ordenação entre os elementos.

Num exemplo maluco, podemos ordenar nossa lista de aulas por ordem de tamanho da string:

aulas.Sort((a, b) => a.Length.CompareTo(b.Length));
Imprimir(aulas);
Copiando lista


Para copiar uma lista, a abordagem é bem diferente daquela que vimos com arrays.

A classe List<T> possui um método chamado GetRange(), para "pegar uma região" de uma lista original e assim gerar uma nova lista com esses elementos copiados:

List<string> copia = aulas.GetRange(aulas.Count - 2, 2);
Imprimir(copia);
Clonando lista


Mas assim como em arrays, se o que você precisa é apenas uma cópia de todos os elementos de uma lista, em vez de usar o método Clone(), você pode clonar criando uma nota instância de List<T> passando como parâmetro do construtor a lista a ser clonada:

List<string> clone = new List<string>(aulas);
Imprimir(clone);
Ufa, quanta coisa!

Listas são coleções importantíssimas em .NET Framework. Dominar os fundamentos dessa coleção é vital para um bom aproveitamento da programação com C#.

E sobre o LINQ? Você pode turbinar suas aplicações com essa incrível ferramenta de consultas em C#, fazendo os cursos LinQ parte 1 e LinQ parte 2 aqui na Alura!

A seguir, vamos começar a estudar um outro tipo de coleção: os conjuntos. Até à próxima!


  //--------------------------------------------------------------------

	* 2 - Aulaa 12 - Para Saber Mais

	Trabalhando com listas
Se quisermos armazenar muitas contas na memória, podemos fazer o uso de arrays, o qual já estudamos nos capítulos anteriores. Arrays nos possibilitam guardar uma quantidade de elementos e depois acessá-los de forma fácil.

Mas o problema é que manipular um array não é fácil. Por exemplo, imagine um array com 5 contas guardadas. Se quisermos remover a posição 1, como fazemos? Pois, se apagarmos, precisaremos reordenar todo nosso array. E para inserir um elemento no meio do array? Precisamos "abrir um buraco" no array, empurrando elementos pra baixo, para aí sim colocar o novo elemento no meio.



Facilitando o trabalho com coleções através das listas
Para resolver os problemas do array, podemos trabalhar com uma classe do C# chamada List. Para utilizarmos uma lista dentro do código precisamos informar qual é o tipo de elemento que a lista armazenará:

// cria uma lista que armazena o tipo Conta
List<Conta> lista = new List<Conta>();
Da mesma forma que criamos a lista de contas, também poderíamos criar uma lista de números inteiros ou de qualquer outro tipo do C#. Essa lista do C# armazena seus elementos dentro de um array.

PARA SABER MAIS:

APOSTILA C# E ORIENTAÇÃO A OBJETOS - Caelum Ensino e Inovação
https://www.caelum.com.br/apostila-csharp-orientacao-objetos

   //--------------------------------------------------------------------
   //--------------------------------------------------------------------
   //--------------------------------------------------------------------
   //--------------------------------------------------------------------

   * 3 - Aula 01 - O Poder dos Sets
   
   No último vídeo vimos bastante sobre listas, e agora começaremos a explorar outros tipos de coleções. Aprenderemos sobre conjuntos (ou "sets" em inglês). No .NET conseguimos implementar conjuntos e, agora que temos Cursos e Aulas, criaremos também Alunos, como sets.

Há duas principais propriedades do set, sendo que a primeira é não permitir duplicidade, ou seja, um elemento não será contido mais de uma vez em um mesmo conjunto. A segunda característica implica nos elementos não serem mantidos em ordem específica quando os incluímos ou removemos.

Para declararmos os alunos como conjuntos, utilizaremos ISet<>, uma interface genérica do .NET que exige que se passe o tipo do elemento deste conjunto (neste caso, string, pois armazenaremos os nomes dos alunos).

Usaremos implementação HashSet<>, também uma classe genérica, com mesmo tipo string. Por termos alunos como conjuntos vazios, começaremos a adicionar elementos:

//declarando set de alunos
ISet<string> alunos = new HashSet<string>();
//adicionando: vanessa, ana, rafael
alunos.Add("Vanessa Tonini");
alunos.Add("Ana Losnak");
alunos.Add("Rafael Nercessian");

//imprimindo
Console.WriteLine(alunos);
Utilizando o atalho "Ctrl + F5", rodaremos a aplicação. Como já era esperado, obteremos o seguinte:

System.Collections.Generic.HashSet`1[System.String]
Não conseguimos imprimir cada um dos alunos, então precisaremos do string.Join:

//imprimindo
Console.WriteLine(alunos);
Console.WriteLine(string.Join(",", alunos));
Podemos rodar a aplicação novamente. Obteremos os nomes impressos como gostaríamos.

Qual a diferença entre um conjunto e uma lista?
Para entendermos isso melhor, adicionaremos mais três alunos a este conjunto:

//adicionando: priscila, rollo, fabio
alunos.Add("Priscila Stuani");
alunos.Add("Rafael Rollo");
alunos.Add("Fabio Gushiken");
Console.WriteLine(string.Join(",", alunos));
Rodaremos o código e teremos os alunos novos acrescentados como gostaríamos. Ok, e a ordem? Como vimos, a segunda propriedade dos conjuntos é não sabermos exatamente em que posição estes alunos irão parar. Se voltarmos à tela de impressão, veremos que aparentemente segue-se a ordem de elementos conforme são colocados. Será que isso vale para todos os casos?

Vamos testar remover um aluno e substituir por outro:

//remover ana, adicionando marcelo
alunos.Remove("Ana Losnak");
alunos.Add("Marcelo Oliveira");
//imprimindo de novo
Console.WriteLine(string.Join(",", alunos));
Veremos que a aluna Ana foi removida tendo o Marcelo adicionado exatamente em sua posição, o que confirma que o conjunto não garante o posicionamento dos elementos.

Vamos testar a primeira propriedade agora, de não permitir duplicidade, adicionando um aluno já existente ao conjunto:

//adicionando gushiken de novo
alunos.Add("Fabio Gushiken");
Console.WriteLine(string.Join(",", alunos));
Será que isto gerará um erro? Ou conseguiremos adicioná-lo? Rodaremos novamente, e confirmamos que o Fabio não aparece duplicado, aparecendo exatamente onde estava anteriormente. Isto é, quando tentamos acrescentar um elemento que já existia no conjunto, não acontece nada.

Qual a vantagem de se usar um conjunto e não uma lista?
A maior diferença em relação às listas é que o conjunto é mais rápido na busca de elementos. No Stack Overflow é possível encontrar questões em relação às performances entre HashSet e uma lista, com gráficos e outros exemplos.

Neles, vê-se que quanto mais elementos existem em uma coleção do tipo lista, maior será o tempo de busca por um elemento. O HashSet, por sua vez, tem um tempo de busca constante, independentemente desta quantidade.

Isto ocorre pois, diferentemente de uma lista, que faz uma varredura do primeiro ao último elemento, o HashSet, na busca de um elemento, utiliza uma tabela de espalhamento, que ocupa um lugar com memória muito maior, no entanto direcionando à posição que o elemento irá ocupar.

Então, com relação ao desempenho, podemos dizer que um HashSet possui grande escalabilidade, permitindo que em uma grande escala de elementos, haja bom desempenho. A memória, porém, é um ponto fraco do HashSet: com grande quantidade de elementos, há consumo bem maior de memória.

Voltando ao nosso código, será que é possível ordenar nosso conjunto de alunos por meio do método Sort(), como em uma lista?

A partir do conjunto de alunos, chamaremos este método e tentaremos rodar o código, que gera um erro indicando que o ISet, tipo de alunos, não contém uma definição para Sort. Já tínhamos visto este problema anteriormente com a lista somente leitura.

Utilizaremos uma técnica similar ao que já foi feito, que é copiar o conjunto para uma lista para podermos ordená-lo, já que a lista possui a implementação do método de ordenação Sort. Criaremos uma nova lista de string denominada alunosEmLista. Como argumento no construtor, passaremos nossa coleção de alunos:

//ordenando: sort
//alunos.Sort();
//copiando: alunosEmLista
List<string> alunosEmLista = new List<string>(alunos);
//ordenando cópia
alunosEmLista.Sort();
//imprimindo cópia
Console.WriteLine(string.Join(",", alunosEmLista));
Com "Ctrl + F5", rodaremos o código de novo, e veremos que conseguimos ordenar os alunos alfabeticamente!


   //--------------------------------------------------------------------
   
	* 3 - Aula 03 - Usando Set Dentro do Modelo

	No último vídeo aprendemos a criar uma coleção de alunos como um conjunto, por meio do HashSet. Para colocá-lo em nosso curso, criaremos um projeto Console Application, mantendo-se as classes do projeto original.

Declararemos o curso chamado "C# Colecoes" em main de Program, e também seu instrutor, "Marcelo Oliveira". Em seguida, adicionaremos as aulas:

class Program
{
    static void Main(string[] args)
    {
        //vamos declarar o curso
        Curso csharpColecoes = new Curso("C# Colecoes", "Marcelo Oliveira");
        //... e adicionar 3 aulas a esse curso
        //Trabalhando com Listas - 21 minutos;
        //Criando uma Aula - 20 minutos;
        //Modelando com Coleções - 24 minutos
        csharpColecoes.Adiciona(new Aula("Trabalhando com Listas", 21));
        csharpColecoes.Adiciona(new Aula("Criando uma Aula", 20));
        csharpColecoes.Adiciona(new Aula("Modelando com Coleções", 24));
    }
}
O que vimos até então é um conjunto de strings, sendo que um aluno pode, também, ter uma matrícula. Para trabalharmos com estas duas informações, criaremos uma classe Aluno, para o qual definiremos duas propriedades com o atalho "propfull + TAB + TAB".

Faremos o mesmo para a matrícula, após o qual criaremos o construtor para esta classe.

namespace A32SetNoModelo
{
    class Aluno
    {
        private string nome;

        public string Nome
        {
            get { return nome; }
            set { nome = value; }
        }

        private int numeroMatricula;

        public int NumeroMatricula
        {
            get { return numeroMatricula; }
            set { numeroMatricula = value; }
        }
    }
}
Colocaremos a linha private int numeroMatricula; logo abaixo de private string nome;, selecionaremos ambas e, com "Ctrl + .", escolheremos "Generate constructor 'Aluno(string, int)'".

Voltando à classe Program.cs, instanciaremos três alunos:

//um aluno também tem matrícula!
//vamos criar a classe Aluno com Nome e NumeroMatricula

//Instanciando 3 alunos com suas matrículas:
//Vanessa Tonini - 34672
//Ana Losnak - 5617
//Rafael Nercessian - 17645
Aluno a1 = new Aluno("Vanessa Tonini", 34672);
Aluno a2 = new Aluno("Ana Losnak", 5617);
Aluno a3 = new Aluno("Rafael Nercessian", 17645);
Precisaremos matriculá-los em nosso curso, portanto chamaremos um método da classe Curso, denominado Matricula(), ainda inexistente. Vamos adicioná-lo por meio de "Ctrl + ." e "Generate method 'Curso.Matricula'".

//Precisamos matricular os alunos no curso, criando um método
csharpColecoes.Matricula(a1);
csharpColecoes.Matricula(a2);
csharpColecoes.Matricula(a3);
Navegaremos a este método, que precisaremos implementar, pela tecla F12. Assim, trocaremos Aluno a1 por Aluno aluno. Feito isto, referenciaremos a coleção de alunos chamando um método de adição, Add():

internal void Matricula(Aluno aluno)
{
    alunos.Add(aluno);
}
O Visual Studio nos informa que alunos não existe na classe Curso, portanto iremos declará-la. Continuaremos trabalhando com conjuntos, porém, desta vez serão de classe Alunos, não mais de strings.

A coleção ReadOnlyCollection receberá o tipo genérico Aluno, e precisaremos resolver a referência utilizando "Ctrl + .", clicando em "using System.Collections.ObjectModel;".

class Curso
{
    //alunos deve ser um ISet. Alunos deve retornar ReadOnlyCollection
    private ISet<Aluno> alunos = new HashSet<Aluno>();
    public IList<Aluno> Alunos
    {
        get
        {
            return new ReadOnlyCollection<Aluno>(alunos);
        }
    }
}
Ao fazermos isto, o programa nos informa que alunos não pode ser convertido para um ISet<>, pois estamos trabalhando com IList<>. Faremos uma conversão de um HashSet para uma lista chamando o método ToList().

get
{
    return new ReadOnlyCollection<Aluno>(alunos.ToList());
}
Pronto! Agora poderemos voltar ao Program.cs e imprimir os alunos matriculados no curso. Para isso, usaremos um laço foreach, mas antes disso imprimiremos um texto com Console.WriteLine();:

//imprimindo os alunos matriculados
Console.WriteLine("Imprimindo os alunos matriculados");
foreach (var aluno in csharpColecoes.Alunos)
{
    Console.WriteLine(aluno);
}
Vamos rodar o programa e verificar seu funcionamento. Obteremos o seguinte, que não é exatamente o que gostaríamos:

Imprimindo os alunos matriculados
A32SetModelo.Aluno
A32SetModelo.Aluno
A32SetModelo.Aluno
Como visto anteriormente, para imprimirmos informações sobre um determinado objeto, é preciso sobrescrever o método ToString(), que vem da classe Object, de onde todos os objetos herdam. Acrescentaremos informações como nome e matrícula do aluno. Na classe Aluno.cs, digitaremos:

public override string ToString()
{
    return $"[Nome: {nome}, Matrícula: {numeroMatricula}]";
}
Rodando-se a aplicação, obteremos a impressão dos três alunos e suas respectivas matrículas conforme desejado, colocando o set dentro do modelo:

Imprimindo os alunos matriculados
[Nome: Vanessa Tonini, Matrícula: 34672]
[Nome: Ana Losnak, Matrícula: 5617]
[Nome: Rafael Nercessian, Matrícula: 17645]

   
   //--------------------------------------------------------------------
   


   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------
   
   
   //--------------------------------------------------------------------

