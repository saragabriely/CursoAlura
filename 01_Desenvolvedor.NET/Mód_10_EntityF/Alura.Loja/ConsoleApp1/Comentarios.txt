
- Selecionando um código e clicando 'Ctrl + Ponto' - É possível criar um método 
com o código selecionado.

//-------------------------------------------------------------------

- Vantagens de trabalhar com Mapeamento Objeto Relacional (ORM)

 . A maior produtividade do desenvolvedor, pois uma vez que ele fica fluente com o ORM 
 que ele desejar usar, ele ganha muito mais tempo para focar em outras partes da 
 aplicação e não precisa se dedicar tanto aos detalhes da persistência tradicional 
 de dados.

  . A maior facilidade de quando refatoramos um código, pois evitamos de ter que fazer 
  toda a parte de conversão de objetos, montar parâmetros e tudo relacionado a montar uma
  query SQL padrão na mão.

  . A possibilidade de não se preocupar em ter que escrever SQL, pois o ORM se encarrega 
  na maior parte disto.

//-----------------------------------------------------------------------

 - Instalar o Entity no projeto - Pois o Entity, diferente do ADO.NET, não vem instalada
 no projeto assim que é criado.
 - A extração / instalação de pacotes no VS é feita através do NuGet.

 - Console do NUGET: Digitar algo e selecionar TAB - O console dá exemplos do que pode
 ser usado

 //----------------------------------------------------------------------
 
 - Na documentação da Microsoft para o EF Core, existe uma página dedicada para os 
 providers existentes atualmente. Por exemplo, existem providers para o MySQL, Postgres 
 e DB2. Infelizmente, durante a escrita desse texto, ainda não havia um provider 
 disponível para o famoso banco de dados Oracle.

 https://docs.microsoft.com/en-us/ef/core/providers/

 - Um desses providers é o InMemory, que é um provider para acessar um banco de dados 
 que fica na própria memória da aplicação. Na página específica deste provider 
 (em inglês), a Microsoft informa que o seu principal uso é para testes em classes que 
 utilizam o EF Core, conforme indicado no texto abaixo:

 - The InMemory provider is useful when you want to test components using something that 
 approximates connecting to the real database, without the overhead of actual database 
 operations.

 - Utilize essa página para se manter atualizado em relação a esse assunto!

 //---------------------------------------------------------------------

 - Todos os passos abaixo que são necessários para podermos utilizar o 
 Entity Framework Core em nossos projetos:

  . Informar no evento de configuração do contexto o nome do banco e sua 
 localização (informar qual banco e qual é o seu endereço para que o Entity 
 possa atuar.)

  .  Criar as propriedades no contexto para dizer quais classes serão 
  persistidas (no contexto criado precisamos especificar quais classes desejamos 
  persistir no banco).

  . Criar um contexto próprio que herda da classe DbContext (precisamos 
  criar um contexto, em geral usando a nomenclatura 
  ModeloDoNegocioContext por convenção, que vai herdar da classe 
  DbContext.)

  . Instalar o Entity Framework através do gerenciador de pacotes Nugget.

// -----------------------------------------------------------------------

 - Para saber mais: como o CHANGETRACKER funciona

 . Nossas classes não tem nenhuma lógica adicional para facilitar o monitoramento 
 de mudanças em suas propriedades. Isto é, elas não herdam de nenhuma classe com 
 esse propósito, e não possuem nenhuma propriedade que registra se foram modificadas 
 (por exemplo,IsDirty). São classes simples que usam o padrão POCO (Plain Old C# 
 Objects).

 . Então, como o ChangeTracker sabe que, quando uma propriedade foi alterada, ele 
 deve fazer um UPDATE no banco?

 . O Entity guarda um snapshot dos valores dos objetos por padrão. Quando aquele 
 objeto começa a ser monitorado pelo Entity, seja através de métodos que recuperam 
 objetos do banco via SELECT (por exemplo ToList, First, Find, etc.), seja através 
 do método Entry que cria uma entrada no ChangeTracker para o objeto passado como 
 argumento do método.

 . E chama o método DetectChanges ao executar o SaveChanges. O que esse método 
 faz? DetectChanges verifica diferenças entre os valores atuais das propriedades 
 da entidade e os valores originais guardados no snapshot quando ela foi anexada 
 ao contexto.

 . É possível desligar o monitoramento automático de mudanças através de uma 
 propriedade booleana no ChangeTracker chamada AutoDetectChangesEnabled. Quando 
 isso é necessário? Quando você tiver uma gravação massiva de objetos através do 
 SaveChanges, a performance pode sofrer impacto considerável, uma vez que o método
 DetectChanges será chamado e o ChangeTracker irá percorrer toda a lista de objetos
 sendo monitorados.

// ----------------------------------------------------------------------

 - Na aula anterior, vimos que quando colocamos o Entity para cuidar das entidades, 
 ele passa a monitorar o estado desses objetos. Quando buscamos dados no banco, o 
 estado veio como Unchanged, ao alterarmos alguma informação do dado, ele passou a 
 ser Modified.

 . O que faremos durante essa parte, não é necessário que você repita. O intuito 
 é mostrar o SQL que o Entity está gerando e qual a relação desse SQL com o estado 
 atual dos objetos.

 . Primeiro vamos configurar alguns detalhes na class Program. Dentro do método 
 Main() vamos adicionar o provedor de serviços GetInfrasctructure<IServiceProvider>(),
 lembrando de adicionar o namespaces.

class Program
{
    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();

            // ...
        }
    }
}

- Pediremos para o serviceProvider fornecer um serviço específico que cria Loggers.

class Program
{
    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();

            // ...
        }
    }
}

 . Com o loggerFactory passaremos para o método AddProvider() um Logger específico 
 que chamaremos de SqlLoggerProvider. O SqlLoggerProvider chama um método chamado 
 Create().

    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            // ...
        }
    }
. Porém a classe SqlLoggerProvider não existe, vamos criá-la.

. Lembrando que todos esses passos não são necessários que sejam feitos, é apenas
para mostrar como o SQL que o Entity está gerando.

 . Criaremos a classe código SqlLoggerProvider e deixaremos da seguinte maneira:

using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.Extensions.Logging;
using System;

namespace Alura.Loja.Testes.ConsoleApp
{
    public class SqlLoggerProvider : ILoggerProvider
    {
        public static ILoggerProvider Create()
        {
            return new SqlLoggerProvider();
        }

        public ILogger CreateLogger(string categoryName)
        {
            if (categoryName == typeof(IRelationalCommandBuilderFactory).FullName)
            {
                return new SqlLogger();
            }
            return new NullLogger();
        } 
        public void Dispose() {  }
    }

    internal class NullLogger : ILogger
    {
        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            //não faz nada
        }
    }

    public class SqlLogger : ILogger
    {
        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            Console.WriteLine("");
            Console.WriteLine(formatter(state, exception));
            Console.WriteLine("");
        }
    }
}
Executando a aplicação veremos o SQl:

SELECT [p].[Id], [p].[Categoria], [p].[Nome], [p].[Preco] 
FROM [Produtos] AS [p]
 . Mostrando também o estado de cada dado. Como o último item da lista estamos 
 modificando o nome e não salvamos, o seu estado é Modified. O que acontecerá 
 quando salvarmos essas alterações?

 . Tiraremos os comentários do comando contexto.SaveChanges(), que está depois da 
 alteração que fizemos no nome do último elemento da lista.

static void Main(string[] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory   = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();
        foreach (var p in produtos)
        {
            Console.WriteLine(p);
        }

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        var p1 = produtos.Last();
        p1.Nome = "007 - O Espiao Que Me Amava";

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }
        contexto.SaveChages();

        //Console.WriteLine("=================");
        //produtos = contexto.Produtos.ToList();
        //foreach (var p in produtos)
        //{ Console.WriteLine(p); }
    }
}
. Executando a aplicação novamente vemos que após apresentar o a mensagem dos 
 estados, foi gerada um SQL para atualizar no banco de dados.

UPDATE [Produtos] SET [Nome] = @p0  WHERE [Id] = @p1;

 . Então, quando chamamos o contexto.SaveChages(), ele olha para cada objeto e 
 verifica o seu estado. Caso seja um estado que é preciso sincronizar com o banco, 
 ele executará o SQL. Para o estado "Modified", ele executa o SQL Update.

 . No próximo vídeo veremos quais são os outros estados.

 //------------------------------------------------------------------------------

 . Aprendemos o que acontece com um dado quando é alterado, o que veremos agora é 
 como o ChangeTracker age ao adicionar um produto.

 . Comentaremos o trecho de código onde alteramos o último produto. Em seguida 
 adicionaremos o um novo produto, e para colocarmos sobre o controle do Entity 
 chamaremos o método contexto.Produtos.Add();

static void Main(string[] args)
{
    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();
        foreach (var p in produtos)
        {
            Console.WriteLine(p);
        }

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        //var p1 = produtos.Last();
        //p1.Nome = "007 - O Espiao Que Me Amava";

        var novoProduto = new Produto()
        {
            Nome = "Desinfetante",
            Categoria = "Limpeza",
            Preco = 2.99;
        };
        contexto.Produtos.Add(novoProduto);

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        contexto.SaveChages();

        //Console.WriteLine("=================");
        //produtos = contexto.Produtos.ToList();
        //foreach (var p in produtos)
        //{
        //    Console.WriteLine(p);
        //}
    }
}
. Para evitarmos a repetição de código, vamos extrair o laço onde mostramos o estado
das entidade no ChangeTracker.

private static void ExibeEntries(IEnumerable<EntityEntry> entries)
{
    Console.WriteLine("===================");
    foreach (var e in entries)
    {
        Console.WriteLine(e);
    }
}
Além do estado, mostraremos também as informações do produto.

private static void ExibeEntries(IEnumerable<EntityEntry> entries)
{
    Console.WriteLine("===================");
    foreach (var e in entries)
    {
        Console.WriteLine(e.Entity.ToString() + " - " + e.State);
    }
}
Na classe Produto dentro do ToString(), colocaremos todas as informações do produto.

namespace Alura.Loja.Testes.ConsoleApp
{
    internal class Produto
    {
        // ...

        public override string ToString()
        {
            return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, {this.Preco}";
        }
    }
}
 . Vamos substituir os laços de repetição por uma chamada do método ExibeEntries(). 
 A classe Program ficará da seguinte maneira:

namespace Alura.Loja.Testes.ConsoleApp
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            var produtos = contexto.Produtos.ToList();

            ExibeEntries(contexto.ChangeTracker.Entries());

            var novoProduto = new Produto
            {
                Nome = "Desinfetante",
                Categoria = "Limpeza",
                Preco = 2.99;
            };
            contexto.Produtos.Add(novoProduto);

            ExibeEntries(contexto.ChangeTracker.Entries());

            contexto.SaveChages();

            ExibeEntries(contexto.ChangeTracker.Entries());

        }
    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        Console.WriteLine("===================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e.Entity.ToString() + " - " + e.State);
        }
    }
}
. Após executar a aplicação, veremos os resultados. O primeiro resultado é o 
comando SQL select. Em seguida foi mostrado todos os dados cadastrados no banco,
com o estado valor Unchanged.

 . O produto "Desinfetante" que adicionamos, está com o menor valor inteiro no Id 
 e com o estado Added. Após ser salvo com o SaveChanges(), o resultado é o comando 
 SQL insert:

INSERT INTO [Produtos] ([Categoria], [Nome], [Preco])
VALUES (@p0, @p1, @p2);

. Novamente um select será gerado trazendo todos os dados cadastrados no banco. 
. Agora o produto "Desinfetante" está com o Id gerado pelo banco e o estado Unchanged.

//-------------------------------------------------------------------------

No último vídeo vimos o estado Added onde ele gera o comando SQL insert. Porém ficou faltando saber como enviar o comando SQL delete.

Você já deve estar imaginando que é por meio do método do Entity contexto.Produtos.Remove(). Faremos alguns exemplos para ver como o ChangeTracker irá se comportar ao chamar o método contexto.Produtos.Remove().

Comentaremos o código onde adicionamos um produto ao contexto e onde salvamos as alterações. Em seguida, pegaremos um produto do banco de dados e armazenaremos em uma variável chamada p1, e passamos como argumento para o contexto.Produtos.Remove().

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        //var novoProduto = new Produto
        //{
        //    Nome = "Desinfetante",
        //    Categoria = "Limpeza",
        //    Preco = 2.99;
        //};
        //contexto.Produtos.Add(novoProduto);

        var p1 = produtos.First();
        contexto.Produtos.Remove(p1);

        ExibeEntries(contexto.ChangeTracker.Entries());

        //contexto.SaveChages();

        //ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Por enquanto não usaremos o contexto.SaveChanges() para salvar as alterações. Rodaremos a aplicação para ver qual estado o Entity colocou para o primeiro produto da lista.

No resultado, vemos que foi executado o comando SQL SELECT para trazer as informações do banco. Após isso, foram apresentados todos os dados com o estado Unchanged. No código removemos o primeiro produto usando o contexto.Produtos.Remove(), dessa forma, o produto foi apresentado com o estado Deleted.

Tiraremos os comentários do contexto.SaveChanges() e do ExibeEntries() que estão após a remoção.

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        //var novoProduto = new Produto
        //{
        //    Nome = "Desinfetante",
        //    Categoria = "Limpeza",
        //    Preco = 2.99;
        //};
        //contexto.Produtos.Add(novoProduto);

        var p1 = produtos.First();
        contexto.Produtos.Remove(p1);

        ExibeEntries(contexto.ChangeTracker.Entries());

        contexto.SaveChages();

        ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Executando a aplicação, notamos que após apresentar os dados e colocar o estado do primeiro dado como Deleted, o Entity executou um comando SQL DELETE.

DELETE FROM [Produtos]
WHERE [Id] = @p0;
Ao mostrar novamente os dados, o primeiro produto da lista já não está sendo controlado pelo Entity e foi removido do banco de dados. Mas o que aconteceria se adicionarmos um produto no Entity e removê-lo antes do contexto.SaveChanges()? Ele enviaria um comando SQL mesmo sem ter o produto no banco de dados?

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        var novoProduto = new Produto
        {
            Nome = "Sabão em pó",
            Categoria = "Limpeza",
            Preco = 5.99;
        };
        contexto.Produtos.Add(novoProduto);

        contexto.Produtos.Remove(novoProduto);

        ExibeEntries(contexto.ChangeTracker.Entries());

        contexto.SaveChages();

        ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Nesse caso, foi executado o comando SQL SELECT para trazer os produtos com o estado Unchanged, porém após adicionar e remover, o produto "Sabão em pó" não apareceu como um produto Added. Isso aconteceu porque após removermos, o Entity retira o produto da sua lista de rastreamento. Com isso, após salvarmos as alterações, não é enviada nenhum comando SQL para o banco.

Mas o que aconteceu com esse produto novoProduto? Podemos ver o seu estado usando o método contexto.Entry() que nos retorna uma variável do tipo EntityEntry. Adicionaremos ao final do método Main():

var entry = contexto.Entry(novoProduto);
Console.WriteLine("\n\n" + entry.Entity.ToString() + " - " + entry.State);
Rodando a aplicação podemos ver que o estado desse produto está como Detached. Este estado representa que o objeto não está sendo monitorado.

//--------------------------------------------------------------

. Com o método ToList(), foi feito um SELECT no banco e trouxe todos os 
 produtos cadastrados,
     
. Recapitularemos o que fizemos durante a aula. Quando usamos o método 
Produtos.ToList(), fizemos um comando SQL SELECT no banco e recebemos os 
produtos com o estado Unchanged

. Após pegarmos o objeto Unchanged e alterarmos algum atributo, ele passa
para o estado Modified.

. Depois de usarmos o método SaveChanges(), é executado um comando SQL 
UPDATE, modificado o estado do produto para Unchanged.

. Quando criamos um produto e adicionamos ao contexto do Entity com o 
método Produtos.Add(), o estado do produto fica Added.

. Depois de usarmos novamente o método SaveChanges(), é executado um 
comando SQL INSERT alterando o estado do produto para Unchaged.

. Quando usamos o Produtos.Remove() em um objeto, ele passa para o 
estado Deleted.

. Quando salvamos as alterações ele passa a ser Detached, que representa 
um objeto que não é mais rastreado pelo Entity. E claro, o produto também
é removido do banco de dados.

. Quando adicionamos um produto e ele é removido sem ter sido salvo com
o SaveChanges(), ele passa de Added para Detached.


. quando você cria um objeto com por exemplo new Produto(), este objeto ainda 
não está sendo monitorado pelo Entity. Ou seja, mesmo que você altere sua propriedades
ele não estará em estado algum! Se você deseja adicionar um objeto que acabou de 
ser criado para que ele seja monitorado, você precisa utilizar o método .Add() ,
e aí assim após você alterar alguma de suas propriedades que ele vai para o 
estado de Modified.

//--------------------------------
	RESUMO DOS ESTADOS

	Added
	. O objeto é novo, foi adicionado ao contexto, e o método SaveChanges ainda 
	não foi executado. Depois que as mudanças são feitas, o estado do objeto muda 
	para Unchanged. Objetos no estado Added não têm seus valores rastreados em 
	sua instância de EntityEntry.

	Deleted
	. O objeto foi excluído do contexto. Depois que as mudanças foram salvas, seu
	estado muda para Detached.

	Detached
	. O objeto existe, mas não está sendo monitorado. Uma entidade fica nesse 
	estado imediatamente após ter sido criada e antes de ser adicionada ao 
	contexto. Ela também fica nesse estado depois que foi removida do contexto 
	através do método Detach ou se é carregada por um método com opção NoTracking.
	Não existem instâncias de EntityEntry associadas a objetos com esse estado.

	Modified
	. Uma das propriedades escalares do objeto foi modificada e o método SaveChanges
	ainda não foi executado. Quando o monitoramento automático de mudanças está 
	desligado, o estado é alterado para Modified apenas quando o método 
	DetectChanges é chamado. Quando as mudanças são salvas, o estado do objeto 
	muda para Unchanged.

	Unchanged
	. O objeto não foi modificado desde que foi anexado ao contexto ou desde a 
	última vez que o método SaveChanges foi chamado.

//------------------------------------------------------

A migração é feita em dois passos. O primeiro passo é executarmos o 
         comando Add-Migration.

    Já o segundo passo pode ser feitas de duas maneiras diferentes, sendo a 
    primeira gerando um script de linguagem DDL com o comando Script-Migration.
    Esse cenário é mais utilizado quando existe uma equipe de banco de dados 
    separada da equipe de desenvolvimento.

    A outra maneira é usarmos o comando Update-Database, onde o Entity pega 
    a nova versão que foi registrada e executa diretamente no banco de dados.
    Vamos utilizar essa segunda forma.

    Começaremos executando o comando para adicionar a migração, passando o 
    nome para ela. Como estamos adicionando uma nova coluna Unidade, daremos 
    o nome da migração de Unidade. O comando ficará:

    Add-Migration Unidade

    Não obtivemos nenhum resultado relevante no Console, mas olhando o projeto 
    podemos ver que uma pasta chamada Migrations foi criada, contendo duas 
    classes.

    A classe que usaremos possui o nome do arquivo com um Timestamp, que é a
    data e hora que o arquivo foi gerado. O nome do arquivo ainda tem a 
    separação por underscore e escrito Unidade.

    Abrindo o arquivo que possui o Timestamp, vemos que é a classe Unidade. 
    A classe Unidade herda de Migration, que nos fornece uma API que fará 
    essa sincronização. Também possui dois métodos, Up que serve para atualizar
    para a versão mais nova das tabelas, e o Down que serve para voltar para 
    uma versão anterior.

    Executaremos o comando para atualizar a tabela, passando o parâmetro 
    -Verbose para que o Console apresente todas as operações. O comando ficará
    da seguinte maneira:

    Update-Database -Verbose

    Após executar o comando, receberemos um erro informando que a tabela 
    Produtos já existe no banco de dados:

    There is already an object named 'Produtos' in the database

    Porém o Entity criou uma tabela chamada __EFMigrationHistory, que é 
    utilizada para manter o histórico de migrações e o Entity utilizará para 
    controlar as versões executadas no banco de dados.

//------------------------------------------------------

        #region Corrigindo problemas e aplicando as migrações no banco
        /*
         No vídeo anterior vimos como trabalhar com a ferramenta de migração do 
         Entity. Criamos uma Migration representando a evolução da classe Produto. 
         Porém quando tentamos executar a migração, recebemos um erro informando 
         que a tabela já existia.

        Esse problema foi porque colocamos a criação da tabela e a evolução na 
        mesma execução. Para resolvermos, nós teríamos que separar a criação da 
        evolução da tabela.

        Começaremos excluindo a tabela __EFMigrationsHistory do banco, e também 
        a pasta Migrations do projeto. Além disso, voltaremos a classe produto 
        para a sua forma inicial:

        namespace Alura.Loja.Testes.ConsoleApp
        {
            internal class Produto
            {
                public int Id { get; internal set; }
                public string Nome { get; internal set; }
                public string Categoria { get; internal set; }
                public double Preco { get; internal set; }

                public override string ToString()
                {
                    return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, 
                    {this.Preco}";
                }
            }
        }
        Executaremos o comando:

        PM> Add-Migration Inicial

        Agora que já criamos a Migration inicial, voltaremos a colocar a evolução 
        da classe, que ficará da seguinte maneira:

        namespace Alura.Loja.Testes.ConsoleApp
        {
            internal class Produto
            {
                public int Id { get; internal set; }
                public string Nome { get; internal set; }
                public string Categoria { get; internal set; }
                public double PrecoUnitario { get; internal set; }
                public string Unidade { get; set; };

                public override string ToString()
                {
                    return $"Produto {this.Id}, {this.Nome}, {this.Categoria}, 
                    {this.PrecoUnitario}";
                }
            }
        }
        Criaremos um nova migração que chamaremos de Unidade. O comando será:

        Add-Migration Unidade

        Acessando a classe de migração Unidade, veremos que ela está bem diferente, 
        refletindo apenas as informações de evolução da tabela. Dentro do método 
        Up() temos a instrução de renomear a coluna Preco para PrecoUnitario, e 
        adicionar uma nova coluna Unidade. Já no método Down, temos a instrução 
        de deletar a coluna Unidade e renomear PrecoUnitario para Preco.

        Tentando executar o comando Update-Database receberemos o mesmo erro 
        informando que a tabela já foi criada. A função da tabela 
        __EFMigrationsHistory é apenas registrar quais migrações foram executadas
        no banco de dados. Ao acessá-la, veremos que nenhuma migração foi 
        executada.

        Levando isso em consideração, ao tentarmos efetuar a migração, ele 
        executará todas as migrações que estão na pasta Migrations, inclusive 
        a migração Inicial.

        Fingiremos para o banco que a migração Inicial já foi executada. 
        Entraremos da classe de migração Inicial e comentaremos todo o conteúdo 
        do método Up(), em seguida executaremos Update-Database Inicial. Isso 
        executará apenas a migração com o nome Inicial e irá criar uma linha na 
        tabela de histórico de migração.

        Agora podemos executar tirar os comentários da classe Inicial e executar 
        o comando Update-Database, dessa vez sem passarmos o nome da classe. 
        A sincronização foi efetuada com sucesso.

        Acessando o banco de dados, veremos que a coluna Preco foi renomeada para
        PrecoUnitario e a coluna Unidade foi criada.

//----------------------------------------------------------------------

	Para saber mais: sincronizando o banco com sua própria aplicação
	PRÓXIMA ATIVIDADE

	. Depois que sua aplicação estiver madura o bastante para ser promovida, surge 
	a questão: como atualizar o banco de dados daquele ambiente específico? Vimos que
	em organizações com políticas de acesso mais restritas a ambientes críticos, a 
	solução é gerar um arquivo com o script das migrações e entregar esse arquivo à 
	equipe responsável. Essa tarefa é realizada com o comando Script-Migration.

	. Além disso, também é possível fazer que sua própria aplicação cuide da migração 
	das versões. Ou seja, podemos escrever código em nossa aplicação para que o banco
	de dados seja sincronizado. Isso é feito através do método de extensão Migrate, 
	que está acessível na propriedade Database da classe DbContext. Essa propriedade 
	representa a instância do banco de dados apontado pelo contexto Entity específico
	de sua aplicação (no nosso exemplo, LojaContext), e expõe métodos que permitem 
	gerenciar o banco apontado pelo contexto, como por exemplo sua criação, exclusão 
	e validação de existência.

	. O método Migrate só pode ser usado em bancos de dados relacionais e fica 
	disponível no pacote Microsoft.EntityFrameworkCore.Relational.

	. Assim, para garantir que todas as migrações estarão aplicadas no banco de dados,
	podemos escrever:

	using(var contexto = new LojaContext())
	{
	  contexto.Database.Migrate();
	}
	. Você precisa garantir que esse código seja executado antes de qualquer acesso
	aos objetos gerenciados pelo contexto. Isso vai depender do tipo de aplicação que 
	será implementada.

//-------------------------------------------------------------------------













