
- Selecionando um código e clicando 'Ctrl + Ponto' - É possível criar um método 
com o código selecionado.

//-------------------------------------------------------------------

- Vantagens de trabalhar com Mapeamento Objeto Relacional (ORM)

 . A maior produtividade do desenvolvedor, pois uma vez que ele fica fluente com o ORM 
 que ele desejar usar, ele ganha muito mais tempo para focar em outras partes da 
 aplicação e não precisa se dedicar tanto aos detalhes da persistência tradicional 
 de dados.

  . A maior facilidade de quando refatoramos um código, pois evitamos de ter que fazer 
  toda a parte de conversão de objetos, montar parâmetros e tudo relacionado a montar uma
  query SQL padrão na mão.

  . A possibilidade de não se preocupar em ter que escrever SQL, pois o ORM se encarrega 
  na maior parte disto.

//-----------------------------------------------------------------------

 - Instalar o Entity no projeto - Pois o Entity, diferente do ADO.NET, não vem instalada
 no projeto assim que é criado.
 - A extração / instalação de pacotes no VS é feita através do NuGet.

 - Console do NUGET: Digitar algo e selecionar TAB - O console dá exemplos do que pode
 ser usado

 //----------------------------------------------------------------------
 
 - Na documentação da Microsoft para o EF Core, existe uma página dedicada para os 
 providers existentes atualmente. Por exemplo, existem providers para o MySQL, Postgres 
 e DB2. Infelizmente, durante a escrita desse texto, ainda não havia um provider 
 disponível para o famoso banco de dados Oracle.

 https://docs.microsoft.com/en-us/ef/core/providers/

 - Um desses providers é o InMemory, que é um provider para acessar um banco de dados 
 que fica na própria memória da aplicação. Na página específica deste provider 
 (em inglês), a Microsoft informa que o seu principal uso é para testes em classes que 
 utilizam o EF Core, conforme indicado no texto abaixo:

 - The InMemory provider is useful when you want to test components using something that 
 approximates connecting to the real database, without the overhead of actual database 
 operations.

 - Utilize essa página para se manter atualizado em relação a esse assunto!

 //---------------------------------------------------------------------

 - Todos os passos abaixo que são necessários para podermos utilizar o 
 Entity Framework Core em nossos projetos:

  . Informar no evento de configuração do contexto o nome do banco e sua 
 localização (informar qual banco e qual é o seu endereço para que o Entity 
 possa atuar.)

  .  Criar as propriedades no contexto para dizer quais classes serão 
  persistidas (no contexto criado precisamos especificar quais classes desejamos 
  persistir no banco).

  . Criar um contexto próprio que herda da classe DbContext (precisamos 
  criar um contexto, em geral usando a nomenclatura 
  ModeloDoNegocioContext por convenção, que vai herdar da classe 
  DbContext.)

  . Instalar o Entity Framework através do gerenciador de pacotes Nugget.

// -----------------------------------------------------------------------

 - Para saber mais: como o CHANGETRACKER funciona

 . Nossas classes não tem nenhuma lógica adicional para facilitar o monitoramento 
 de mudanças em suas propriedades. Isto é, elas não herdam de nenhuma classe com 
 esse propósito, e não possuem nenhuma propriedade que registra se foram modificadas 
 (por exemplo,IsDirty). São classes simples que usam o padrão POCO (Plain Old C# 
 Objects).

 . Então, como o ChangeTracker sabe que, quando uma propriedade foi alterada, ele 
 deve fazer um UPDATE no banco?

 . O Entity guarda um snapshot dos valores dos objetos por padrão. Quando aquele 
 objeto começa a ser monitorado pelo Entity, seja através de métodos que recuperam 
 objetos do banco via SELECT (por exemplo ToList, First, Find, etc.), seja através 
 do método Entry que cria uma entrada no ChangeTracker para o objeto passado como 
 argumento do método.

 . E chama o método DetectChanges ao executar o SaveChanges. O que esse método 
 faz? DetectChanges verifica diferenças entre os valores atuais das propriedades 
 da entidade e os valores originais guardados no snapshot quando ela foi anexada 
 ao contexto.

 . É possível desligar o monitoramento automático de mudanças através de uma 
 propriedade booleana no ChangeTracker chamada AutoDetectChangesEnabled. Quando 
 isso é necessário? Quando você tiver uma gravação massiva de objetos através do 
 SaveChanges, a performance pode sofrer impacto considerável, uma vez que o método
 DetectChanges será chamado e o ChangeTracker irá percorrer toda a lista de objetos
 sendo monitorados.

// ----------------------------------------------------------------------

 - Na aula anterior, vimos que quando colocamos o Entity para cuidar das entidades, 
 ele passa a monitorar o estado desses objetos. Quando buscamos dados no banco, o 
 estado veio como Unchanged, ao alterarmos alguma informação do dado, ele passou a 
 ser Modified.

 . O que faremos durante essa parte, não é necessário que você repita. O intuito 
 é mostrar o SQL que o Entity está gerando e qual a relação desse SQL com o estado 
 atual dos objetos.

 . Primeiro vamos configurar alguns detalhes na class Program. Dentro do método 
 Main() vamos adicionar o provedor de serviços GetInfrasctructure<IServiceProvider>(),
 lembrando de adicionar o namespaces.

class Program
{
    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();

            // ...
        }
    }
}

- Pediremos para o serviceProvider fornecer um serviço específico que cria Loggers.

class Program
{
    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();

            // ...
        }
    }
}

 . Com o loggerFactory passaremos para o método AddProvider() um Logger específico 
 que chamaremos de SqlLoggerProvider. O SqlLoggerProvider chama um método chamado 
 Create().

    static void Main(string[] args)
    {
        using (var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            // ...
        }
    }
. Porém a classe SqlLoggerProvider não existe, vamos criá-la.

. Lembrando que todos esses passos não são necessários que sejam feitos, é apenas
para mostrar como o SQL que o Entity está gerando.

 . Criaremos a classe código SqlLoggerProvider e deixaremos da seguinte maneira:

using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.Extensions.Logging;
using System;

namespace Alura.Loja.Testes.ConsoleApp
{
    public class SqlLoggerProvider : ILoggerProvider
    {
        public static ILoggerProvider Create()
        {
            return new SqlLoggerProvider();
        }

        public ILogger CreateLogger(string categoryName)
        {
            if (categoryName == typeof(IRelationalCommandBuilderFactory).FullName)
            {
                return new SqlLogger();
            }
            return new NullLogger();
        } 
        public void Dispose() {  }
    }

    internal class NullLogger : ILogger
    {
        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            //não faz nada
        }
    }

    public class SqlLogger : ILogger
    {
        public IDisposable BeginScope<TState>(TState state)
        {
            return null;
        }

        public bool IsEnabled(LogLevel logLevel)
        {
            return true;
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            Console.WriteLine("");
            Console.WriteLine(formatter(state, exception));
            Console.WriteLine("");
        }
    }
}
Executando a aplicação veremos o SQl:

SELECT [p].[Id], [p].[Categoria], [p].[Nome], [p].[Preco] 
FROM [Produtos] AS [p]
 . Mostrando também o estado de cada dado. Como o último item da lista estamos 
 modificando o nome e não salvamos, o seu estado é Modified. O que acontecerá 
 quando salvarmos essas alterações?

 . Tiraremos os comentários do comando contexto.SaveChanges(), que está depois da 
 alteração que fizemos no nome do último elemento da lista.

static void Main(string[] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory   = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();
        foreach (var p in produtos)
        {
            Console.WriteLine(p);
        }

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        var p1 = produtos.Last();
        p1.Nome = "007 - O Espiao Que Me Amava";

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }
        contexto.SaveChages();

        //Console.WriteLine("=================");
        //produtos = contexto.Produtos.ToList();
        //foreach (var p in produtos)
        //{ Console.WriteLine(p); }
    }
}
. Executando a aplicação novamente vemos que após apresentar o a mensagem dos 
 estados, foi gerada um SQL para atualizar no banco de dados.

UPDATE [Produtos] SET [Nome] = @p0  WHERE [Id] = @p1;

 . Então, quando chamamos o contexto.SaveChages(), ele olha para cada objeto e 
 verifica o seu estado. Caso seja um estado que é preciso sincronizar com o banco, 
 ele executará o SQL. Para o estado "Modified", ele executa o SQL Update.

 . No próximo vídeo veremos quais são os outros estados.

 //------------------------------------------------------------------------------

 . Aprendemos o que acontece com um dado quando é alterado, o que veremos agora é 
 como o ChangeTracker age ao adicionar um produto.

 . Comentaremos o trecho de código onde alteramos o último produto. Em seguida 
 adicionaremos o um novo produto, e para colocarmos sobre o controle do Entity 
 chamaremos o método contexto.Produtos.Add();

static void Main(string[] args)
{
    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();
        foreach (var p in produtos)
        {
            Console.WriteLine(p);
        }

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        //var p1 = produtos.Last();
        //p1.Nome = "007 - O Espiao Que Me Amava";

        var novoProduto = new Produto()
        {
            Nome = "Desinfetante",
            Categoria = "Limpeza",
            Preco = 2.99;
        };
        contexto.Produtos.Add(novoProduto);

        Console.WriteLine("=================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e);
        }

        contexto.SaveChages();

        //Console.WriteLine("=================");
        //produtos = contexto.Produtos.ToList();
        //foreach (var p in produtos)
        //{
        //    Console.WriteLine(p);
        //}
    }
}
. Para evitarmos a repetição de código, vamos extrair o laço onde mostramos o estado
das entidade no ChangeTracker.

private static void ExibeEntries(IEnumerable<EntityEntry> entries)
{
    Console.WriteLine("===================");
    foreach (var e in entries)
    {
        Console.WriteLine(e);
    }
}
Além do estado, mostraremos também as informações do produto.

private static void ExibeEntries(IEnumerable<EntityEntry> entries)
{
    Console.WriteLine("===================");
    foreach (var e in entries)
    {
        Console.WriteLine(e.Entity.ToString() + " - " + e.State);
    }
}
Na classe Produto dentro do ToString(), colocaremos todas as informações do produto.

namespace Alura.Loja.Testes.ConsoleApp
{
    internal class Produto
    {
        // ...

        public override string ToString()
        {
            return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, {this.Preco}";
        }
    }
}
 . Vamos substituir os laços de repetição por uma chamada do método ExibeEntries(). 
 A classe Program ficará da seguinte maneira:

namespace Alura.Loja.Testes.ConsoleApp
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            var produtos = contexto.Produtos.ToList();

            ExibeEntries(contexto.ChangeTracker.Entries());

            var novoProduto = new Produto
            {
                Nome = "Desinfetante",
                Categoria = "Limpeza",
                Preco = 2.99;
            };
            contexto.Produtos.Add(novoProduto);

            ExibeEntries(contexto.ChangeTracker.Entries());

            contexto.SaveChages();

            ExibeEntries(contexto.ChangeTracker.Entries());

        }
    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        Console.WriteLine("===================");
        foreach (var e in contexto.ChangeTracker.Entries())
        {
            Console.WriteLine(e.Entity.ToString() + " - " + e.State);
        }
    }
}
. Após executar a aplicação, veremos os resultados. O primeiro resultado é o 
comando SQL select. Em seguida foi mostrado todos os dados cadastrados no banco,
com o estado valor Unchanged.

 . O produto "Desinfetante" que adicionamos, está com o menor valor inteiro no Id 
 e com o estado Added. Após ser salvo com o SaveChanges(), o resultado é o comando 
 SQL insert:

INSERT INTO [Produtos] ([Categoria], [Nome], [Preco])
VALUES (@p0, @p1, @p2);

. Novamente um select será gerado trazendo todos os dados cadastrados no banco. 
. Agora o produto "Desinfetante" está com o Id gerado pelo banco e o estado Unchanged.

//-------------------------------------------------------------------------

No último vídeo vimos o estado Added onde ele gera o comando SQL insert. Porém ficou faltando saber como enviar o comando SQL delete.

Você já deve estar imaginando que é por meio do método do Entity contexto.Produtos.Remove(). Faremos alguns exemplos para ver como o ChangeTracker irá se comportar ao chamar o método contexto.Produtos.Remove().

Comentaremos o código onde adicionamos um produto ao contexto e onde salvamos as alterações. Em seguida, pegaremos um produto do banco de dados e armazenaremos em uma variável chamada p1, e passamos como argumento para o contexto.Produtos.Remove().

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        //var novoProduto = new Produto
        //{
        //    Nome = "Desinfetante",
        //    Categoria = "Limpeza",
        //    Preco = 2.99;
        //};
        //contexto.Produtos.Add(novoProduto);

        var p1 = produtos.First();
        contexto.Produtos.Remove(p1);

        ExibeEntries(contexto.ChangeTracker.Entries());

        //contexto.SaveChages();

        //ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Por enquanto não usaremos o contexto.SaveChanges() para salvar as alterações. Rodaremos a aplicação para ver qual estado o Entity colocou para o primeiro produto da lista.

No resultado, vemos que foi executado o comando SQL SELECT para trazer as informações do banco. Após isso, foram apresentados todos os dados com o estado Unchanged. No código removemos o primeiro produto usando o contexto.Produtos.Remove(), dessa forma, o produto foi apresentado com o estado Deleted.

Tiraremos os comentários do contexto.SaveChanges() e do ExibeEntries() que estão após a remoção.

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        //var novoProduto = new Produto
        //{
        //    Nome = "Desinfetante",
        //    Categoria = "Limpeza",
        //    Preco = 2.99;
        //};
        //contexto.Produtos.Add(novoProduto);

        var p1 = produtos.First();
        contexto.Produtos.Remove(p1);

        ExibeEntries(contexto.ChangeTracker.Entries());

        contexto.SaveChages();

        ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Executando a aplicação, notamos que após apresentar os dados e colocar o estado do primeiro dado como Deleted, o Entity executou um comando SQL DELETE.

DELETE FROM [Produtos]
WHERE [Id] = @p0;
Ao mostrar novamente os dados, o primeiro produto da lista já não está sendo controlado pelo Entity e foi removido do banco de dados. Mas o que aconteceria se adicionarmos um produto no Entity e removê-lo antes do contexto.SaveChanges()? Ele enviaria um comando SQL mesmo sem ter o produto no banco de dados?

static void Main(String [] args)
{
    using(var contexto = LojaContext())
    {
        var serviceProvider = contexto.GetInfrasctructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var produtos = contexto.Produtos.ToList();

        ExibeEntries(contexto.ChangeTracker.Entries());

        var novoProduto = new Produto
        {
            Nome = "Sabão em pó",
            Categoria = "Limpeza",
            Preco = 5.99;
        };
        contexto.Produtos.Add(novoProduto);

        contexto.Produtos.Remove(novoProduto);

        ExibeEntries(contexto.ChangeTracker.Entries());

        contexto.SaveChages();

        ExibeEntries(contexto.ChangeTracker.Entries());

    }
}
Nesse caso, foi executado o comando SQL SELECT para trazer os produtos com o estado Unchanged, porém após adicionar e remover, o produto "Sabão em pó" não apareceu como um produto Added. Isso aconteceu porque após removermos, o Entity retira o produto da sua lista de rastreamento. Com isso, após salvarmos as alterações, não é enviada nenhum comando SQL para o banco.

Mas o que aconteceu com esse produto novoProduto? Podemos ver o seu estado usando o método contexto.Entry() que nos retorna uma variável do tipo EntityEntry. Adicionaremos ao final do método Main():

var entry = contexto.Entry(novoProduto);
Console.WriteLine("\n\n" + entry.Entity.ToString() + " - " + entry.State);
Rodando a aplicação podemos ver que o estado desse produto está como Detached. Este estado representa que o objeto não está sendo monitorado.

//--------------------------------------------------------------

. Com o método ToList(), foi feito um SELECT no banco e trouxe todos os 
 produtos cadastrados,
     
. Recapitularemos o que fizemos durante a aula. Quando usamos o método 
Produtos.ToList(), fizemos um comando SQL SELECT no banco e recebemos os 
produtos com o estado Unchanged

. Após pegarmos o objeto Unchanged e alterarmos algum atributo, ele passa
para o estado Modified.

. Depois de usarmos o método SaveChanges(), é executado um comando SQL 
UPDATE, modificado o estado do produto para Unchanged.

. Quando criamos um produto e adicionamos ao contexto do Entity com o 
método Produtos.Add(), o estado do produto fica Added.

. Depois de usarmos novamente o método SaveChanges(), é executado um 
comando SQL INSERT alterando o estado do produto para Unchaged.

. Quando usamos o Produtos.Remove() em um objeto, ele passa para o 
estado Deleted.

. Quando salvamos as alterações ele passa a ser Detached, que representa 
um objeto que não é mais rastreado pelo Entity. E claro, o produto também
é removido do banco de dados.

. Quando adicionamos um produto e ele é removido sem ter sido salvo com
o SaveChanges(), ele passa de Added para Detached.


. quando você cria um objeto com por exemplo new Produto(), este objeto ainda 
não está sendo monitorado pelo Entity. Ou seja, mesmo que você altere sua propriedades
ele não estará em estado algum! Se você deseja adicionar um objeto que acabou de 
ser criado para que ele seja monitorado, você precisa utilizar o método .Add() ,
e aí assim após você alterar alguma de suas propriedades que ele vai para o 
estado de Modified.

//--------------------------------
	RESUMO DOS ESTADOS

	Added
	. O objeto é novo, foi adicionado ao contexto, e o método SaveChanges ainda 
	não foi executado. Depois que as mudanças são feitas, o estado do objeto muda 
	para Unchanged. Objetos no estado Added não têm seus valores rastreados em 
	sua instância de EntityEntry.

	Deleted
	. O objeto foi excluído do contexto. Depois que as mudanças foram salvas, seu
	estado muda para Detached.

	Detached
	. O objeto existe, mas não está sendo monitorado. Uma entidade fica nesse 
	estado imediatamente após ter sido criada e antes de ser adicionada ao 
	contexto. Ela também fica nesse estado depois que foi removida do contexto 
	através do método Detach ou se é carregada por um método com opção NoTracking.
	Não existem instâncias de EntityEntry associadas a objetos com esse estado.

	Modified
	. Uma das propriedades escalares do objeto foi modificada e o método SaveChanges
	ainda não foi executado. Quando o monitoramento automático de mudanças está 
	desligado, o estado é alterado para Modified apenas quando o método 
	DetectChanges é chamado. Quando as mudanças são salvas, o estado do objeto 
	muda para Unchanged.

	Unchanged
	. O objeto não foi modificado desde que foi anexado ao contexto ou desde a 
	última vez que o método SaveChanges foi chamado.

//------------------------------------------------------

A migração é feita em dois passos. O primeiro passo é executarmos o 
         comando Add-Migration.

    Já o segundo passo pode ser feitas de duas maneiras diferentes, sendo a 
    primeira gerando um script de linguagem DDL com o comando Script-Migration.
    Esse cenário é mais utilizado quando existe uma equipe de banco de dados 
    separada da equipe de desenvolvimento.

    A outra maneira é usarmos o comando Update-Database, onde o Entity pega 
    a nova versão que foi registrada e executa diretamente no banco de dados.
    Vamos utilizar essa segunda forma.

    Começaremos executando o comando para adicionar a migração, passando o 
    nome para ela. Como estamos adicionando uma nova coluna Unidade, daremos 
    o nome da migração de Unidade. O comando ficará:

    Add-Migration Unidade

    Não obtivemos nenhum resultado relevante no Console, mas olhando o projeto 
    podemos ver que uma pasta chamada Migrations foi criada, contendo duas 
    classes.

    A classe que usaremos possui o nome do arquivo com um Timestamp, que é a
    data e hora que o arquivo foi gerado. O nome do arquivo ainda tem a 
    separação por underscore e escrito Unidade.

    Abrindo o arquivo que possui o Timestamp, vemos que é a classe Unidade. 
    A classe Unidade herda de Migration, que nos fornece uma API que fará 
    essa sincronização. Também possui dois métodos, Up que serve para atualizar
    para a versão mais nova das tabelas, e o Down que serve para voltar para 
    uma versão anterior.

    Executaremos o comando para atualizar a tabela, passando o parâmetro 
    -Verbose para que o Console apresente todas as operações. O comando ficará
    da seguinte maneira:

    Update-Database -Verbose

    Após executar o comando, receberemos um erro informando que a tabela 
    Produtos já existe no banco de dados:

    There is already an object named 'Produtos' in the database

    Porém o Entity criou uma tabela chamada __EFMigrationHistory, que é 
    utilizada para manter o histórico de migrações e o Entity utilizará para 
    controlar as versões executadas no banco de dados.

//------------------------------------------------------

        #region Corrigindo problemas e aplicando as migrações no banco
        /*
         No vídeo anterior vimos como trabalhar com a ferramenta de migração do 
         Entity. Criamos uma Migration representando a evolução da classe Produto. 
         Porém quando tentamos executar a migração, recebemos um erro informando 
         que a tabela já existia.

        Esse problema foi porque colocamos a criação da tabela e a evolução na 
        mesma execução. Para resolvermos, nós teríamos que separar a criação da 
        evolução da tabela.

        Começaremos excluindo a tabela __EFMigrationsHistory do banco, e também 
        a pasta Migrations do projeto. Além disso, voltaremos a classe produto 
        para a sua forma inicial:

        namespace Alura.Loja.Testes.ConsoleApp
        {
            internal class Produto
            {
                public int Id { get; internal set; }
                public string Nome { get; internal set; }
                public string Categoria { get; internal set; }
                public double Preco { get; internal set; }

                public override string ToString()
                {
                    return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, 
                    {this.Preco}";
                }
            }
        }
        Executaremos o comando:

        PM> Add-Migration Inicial

        Agora que já criamos a Migration inicial, voltaremos a colocar a evolução 
        da classe, que ficará da seguinte maneira:

        namespace Alura.Loja.Testes.ConsoleApp
        {
            internal class Produto
            {
                public int Id { get; internal set; }
                public string Nome { get; internal set; }
                public string Categoria { get; internal set; }
                public double PrecoUnitario { get; internal set; }
                public string Unidade { get; set; };

                public override string ToString()
                {
                    return $"Produto {this.Id}, {this.Nome}, {this.Categoria}, 
                    {this.PrecoUnitario}";
                }
            }
        }
        Criaremos um nova migração que chamaremos de Unidade. O comando será:

        Add-Migration Unidade

        Acessando a classe de migração Unidade, veremos que ela está bem diferente, 
        refletindo apenas as informações de evolução da tabela. Dentro do método 
        Up() temos a instrução de renomear a coluna Preco para PrecoUnitario, e 
        adicionar uma nova coluna Unidade. Já no método Down, temos a instrução 
        de deletar a coluna Unidade e renomear PrecoUnitario para Preco.

        Tentando executar o comando Update-Database receberemos o mesmo erro 
        informando que a tabela já foi criada. A função da tabela 
        __EFMigrationsHistory é apenas registrar quais migrações foram executadas
        no banco de dados. Ao acessá-la, veremos que nenhuma migração foi 
        executada.

        Levando isso em consideração, ao tentarmos efetuar a migração, ele 
        executará todas as migrações que estão na pasta Migrations, inclusive 
        a migração Inicial.

        Fingiremos para o banco que a migração Inicial já foi executada. 
        Entraremos da classe de migração Inicial e comentaremos todo o conteúdo 
        do método Up(), em seguida executaremos Update-Database Inicial. Isso 
        executará apenas a migração com o nome Inicial e irá criar uma linha na 
        tabela de histórico de migração.

        Agora podemos executar tirar os comentários da classe Inicial e executar 
        o comando Update-Database, dessa vez sem passarmos o nome da classe. 
        A sincronização foi efetuada com sucesso.

        Acessando o banco de dados, veremos que a coluna Preco foi renomeada para
        PrecoUnitario e a coluna Unidade foi criada.

//----------------------------------------------------------------------

	Para saber mais: sincronizando o banco com sua própria aplicação
	PRÓXIMA ATIVIDADE

	. Depois que sua aplicação estiver madura o bastante para ser promovida, surge 
	a questão: como atualizar o banco de dados daquele ambiente específico? Vimos que
	em organizações com políticas de acesso mais restritas a ambientes críticos, a 
	solução é gerar um arquivo com o script das migrações e entregar esse arquivo à 
	equipe responsável. Essa tarefa é realizada com o comando Script-Migration.

	. Além disso, também é possível fazer que sua própria aplicação cuide da migração 
	das versões. Ou seja, podemos escrever código em nossa aplicação para que o banco
	de dados seja sincronizado. Isso é feito através do método de extensão Migrate, 
	que está acessível na propriedade Database da classe DbContext. Essa propriedade 
	representa a instância do banco de dados apontado pelo contexto Entity específico
	de sua aplicação (no nosso exemplo, LojaContext), e expõe métodos que permitem 
	gerenciar o banco apontado pelo contexto, como por exemplo sua criação, exclusão 
	e validação de existência.

	. O método Migrate só pode ser usado em bancos de dados relacionais e fica 
	disponível no pacote Microsoft.EntityFrameworkCore.Relational.

	. Assim, para garantir que todas as migrações estarão aplicadas no banco de dados,
	podemos escrever:

	using(var contexto = new LojaContext())
	{
	  contexto.Database.Migrate();
	}
	. Você precisa garantir que esse código seja executado antes de qualquer acesso
	aos objetos gerenciados pelo contexto. Isso vai depender do tipo de aplicação que 
	será implementada.

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------

	AULA 05

 * 1 - Relacionamento um para muitos

 . Na aula anterior aprendemos como o Entity sincroniza estrutura das classes 
 entidade, com a estrutura das tabelas no banco de dados. Isso era necessário 
 porque precisávamos evoluir a aplicação.

 . Para uma loja prosperar, é necessário que os clientes comprem. Nessa aula, 
 modelaremos o conceito de compra, em uma nova classe e relacionaremos com o 
 produto. Dessa forma veremos como o Entity trabalhará com relacionamentos.

 . Na classe Program dentro do método Main(), simularemos uma compra de um produto. 
 Começaremos criando um novo produto e popularemos:

class Program
{
    static void Main(string[] args)
    {
        //compra de 6 pães franceses
        var paoFrances = new Produto();
        paoFrances.Nome = "Pão Francês";
        paoFrances.PrecoUnitario = 0.40;
        paoFrances.Unidade = "Unidade";
        paoFrances.Categoria = "Padaria";
    }
}
. Mas como simularemos uma compra? Instanciaremos a classe Compra, populando os 
atributos Quantidade, Produto e Preco. O valor de Preco é a multiplicação entre o
PrecoUnitario do produto e a Quantidade da compra.

class Program
{
    static void Main(string[] args)
    {
        //compra de 6 pães franceses
        var paoFrances = new Produto();
        paoFrances.Nome = "Pão Francês";
        paoFrances.PrecoUnitario = 0.40;
        paoFrances.Unidade = "Unidade";
        paoFrances.Categoria = "Padaria";

        var compra = new Compra();
        compra.Quantidade = 6;
        compra.Produto = paoFrances;
        compra.Preco = paoFrances.PrecoUnitario * compra.Quantidade;
    }
}
 . Como a classe e as propriedades ainda não foram criadas, podemos usar o atalho 
 "Ctrl + . (ponto)" do Visual Studio, e pedir a criação. Podemos persistir as 
 informações da compra no banco de dados, porém ainda não possuímos a tabela que
 representa a classe Compra. Para sincronizar a classe com o banco, usaremos 
 novamente Migrations.

//-------------------------------------------------------------------------

	* 2 Corrigindo a migração para refletir o relacionamento

 . Antes de criarmos a migração para representar a classe, entraremos na classe 
 Compra e adicionaremos uma propriedade Id. Essa propriedade irá representar a 
 chave primária da compra. Também removeremos o construtor da classe, que foi 
 gerado automaticamente pelo Visual Studio.

namespace Alura.Loja.Testes.ConsoleApp
{
    internal class Compra
    {
        public int Id { get; set; }
        public int Quantidade { get; internal set; }
        public Produto Produto { get; internal set; }
        public double Preco { get; internal set; }
    }
}
Abriremos o Console do Gerenciador de Pacotes do NuGet, e digitaremos o comando para adicionarmos a migração:

PM> Add-Migration Compra

Abriremos a classe de migração Compra. Podemos notar que os métodos Up() e Down() estão vazios. O que queremos é criar a tabela Compra no banco de dados, mas o que fizemos de errado?

Estamos esquecendo de um passo importante, que é dizer pro Entity gerenciar a persistência da classe Compra. Para fazermos isso, acessaremos a classe de contexto LojaContext, e criaremos uma propriedade DbSet<Compra> Compras.

using Microsoft.EntityFrameworkCore;
using System;

namespace Alura.Loja.Testes.ConsoleApp
{
    internal class LojaContext : DbContext
    {
        public DbSet<Produto> Produtos { get; set; }
        public DbSet<Compras> Compras { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=LojaDB;Trusted_Connection=true;")
        }
    }
}
 . Removeremos a migração que acabamos de fazer executando o comando Remove-Migration
 no Console. A classe de migração com os métodos Up() e Down() vazias, será excluída.

 . Rodaremos novamente o comando Add-Migration Compra. A classe criada para essa 
 migração possui código nos métodos Up() e Down(). Basicamente o método Up() irá 
 criar uma tabela com as colunas Id, Preco, ProdutoId e Quantidade.

 . Não criamos nenhuma propriedade na classe Compras com o nome ProdutoId, então 
 de onde veio essa coluna? Isso acontece porque no modelo relacional não é possível
 guardar uma referência para um objeto, como fazemos no modelo orientado a objetos.
 Justamente por isso, no modelo relacional é guardado uma referência para a chave 
 primária do produto, e o Entity usa na coluna a convenção [nome da classe]Id.

 . É sempre importante analisarmos o código antes de atualizar as migrações. A 
 linha de criação da coluna ProdutoId permite que um produto seja nulo:

ProdutoId = table.Column<int>(nullable: true);

 . Quando efetuamos uma compra, é obrigatório ter um produto. Essa migração não 
 está atendendo as nossas necessidades. Por isso iremos removê-la com o comando 
 Remove-Migration.

 . Para indicar que um Produto é obrigatório, iremos deixar explícito a chave 
 estrangeira ProdutoId.

namespace Alura.Loja.Testes.ConsoleApp
{
    internal class Compra
    {
        public int Id { get; set; }
        public int Quantidade { get; internal set; }
        public int ProdutoId { get; set; }
        public Produto Produto { get; internal set; }
        public double Preco { get; internal set; }
    }
}
 . Como um valor do tipo int não pode ser nulo, o Entity irá interpretar que a 
 propriedade deve ser obrigatória. Executaremos o comando Add-Migration Compra 
 para adicionar a migração.

 . Podemos ver na classe de migração Compra, que a coluna ProdutoId não permite 
 valores nulos:

ProdutoId = table.Column<int>(nullable: false);

 . Finalmente podemos sincronizar essa migração com o banco de dados, usaremos o 
 comando Update-Database. A tabela Compras foi criada, e a migração foi adicionada
 no histórico de migrações na tabela __EFMigrationsHistory.

//-------------------------------------------------------------------------

	* 5 - Inserindo objetos relacionados

 . Anteriormente, criamos uma nova classe chamada Compra e sincronizamos o modelo de 
 classe com o banco usando o recurso de Migrations. Temos tudo que precisamos para 
 registrar a compra do banco de dados.

 . Na classe Program, iremos instanciar um objeto do contexto de LojaContext. Com o 
 objeto, iremos adicionar a compra ao contexto do Entity e salvar as alterações. 
 Para visualizarmos as ações, colocaremos o código de Logger. A classe ficará da 
 seguinte maneira:

class Program
{
    static void Main(string[] args)
    {
        //compra de 6 pães franceses
        var paoFrances = new Produto();
        paoFrances.Nome = "Pão Francês";
        paoFrances.PrecoUnitario = 0.40;
        paoFrances.Unidade = "Unidade";
        paoFrances.Categoria = "Padaria";

        var compra = new Compra();
        compra.Quantidade = 6;
        compra.Produto = paoFrances;
        compra.Preco = paoFrances.PrecoUnitario * compra.Quantidade;

        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            contexto.Compras.Add(compra);

            contexto.SaveChanges();
        }
    }
}
 . Sabemos que o estado de compra vai ser Added, mas qual será o estado do 
 paoFrances? Nós não pegamos o paoFrances do banco de dados, ele é um produto 
 novo. Tivemos todo o trabalho de refazer a migração Compra justamente para não 
 ter um produto nulo, como será que o Entity irá reagir nessa situação?

 . Quando adicionarmos o compra no Change Tracker, o Entity perceberá que existe 
 uma referência ao produto paoFrances e também o incluirá para ser supervisionado.

 . Comentaremos a linha do SaveChanges(), e colocaremos na classe Program o método
 ExibeEntries() que usamos nas aulas anteriores.

class Program
{
    static void Main (string [] args)
    {
        //compra de 6 pães franceses
        var paoFrances = new Produto();
        paoFrances.Nome = "Pão Francês";
        paoFrances.PrecoUnitario = 0.40;
        paoFrances.Unidade = "Unidade";
        paoFrances.Categoria = "Padaria";

        var compra = new Compra();
        compra.Quantidade = 6;
        compra.Produto = paoFrances;
        compra.Preco = paoFrances.PrecoUnitario * compra.Quantidade;

        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfraestructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());

            contexto.Compras.Add(compra);

            ExibeEntries(contexto.ChangeTracker.Entries());

            //contexto.SaveChanges();
        }
    }
    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        foreach(var e in entries)
        {
            Console.WriteLine(e.Entity.ToString() + " - " + e.State);
        }
    }
}
 . Executaremos a aplicação, como resultado veremos que temos duas entidades, um 
 do tipo Compra e outro do tipo Produto. As duas entidades estão com o estado Added, 
 por isso o Entity irá gerar o comando SQL INSERT para cada um deles. O contexto 
 foi esperto o suficiente para adicionar a referência do produto contida na compra.

 . Removeremos o comentário da linha contexto.SaveChanges() e executaremos a 
 aplicação. Veremos que o Entity inseriu primeiro o produto no banco de dados, 
 depois inseriu a compra, justamente por ser necessário ter um produto preenchido 
 para incluirmos a compra. Se olharmos o banco, veremos todas as informações 
 persistidas.


//-------------------------------------------------------------------------

	* 6 - 01 - Relacionamento muitos para muitos e a classe de join

 . Na aula anterior introduzimos a classe Compra, para representarmos a compra 
 de um produto com base no preço e quantidade. Utilizamos essa funcionalidade para 
 introduzir o conceito de relacionamento entre entidades. Nessa aula continuaremos 
 falando sobre relacionamentos, porém em vez de ter relacionamento apenas com a 
 instância de uma única classe, faremos o relacionamento para uma coleção de
 instâncias.

 . Vamos imaginar que a nossa loja crie regularmente, promoções para baixar o 
 estoque dos produtos. Representaremos esse conceito criando uma classe chamada 
 de Promocao.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Promocao
    {

    }
}
. Agora na classe Program, dentro do método Main() criaremos um cenário para essas
promoções. Deixaremos dentro do método apenas a instancia do contexto do Entity e 
o código do Logger.

 . Instanciaremos uma promoção e armazenaremos em um objeto chamado promocaoDePascoa. 
A partir desse objeto, chamaremos as propriedades Descricao, DataInicio, DataTermino. 
Além dessas propriedades, adicionaremos três produtos na propriedade Produtos.

class Program
{
    static void Main(string[] args)
    {
        var promocaoDePascoa = new Promocao();
        promocaoDePascoa.Descricao = "Páscoa Feliz";
        promocaoDePascoa.DataInicio = DateTime.Now;
        promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);
        promocaoDePascoa.Produtos.Add(new Produto());
        promocaoDePascoa.Produtos.Add(new Produto());
        promocaoDePascoa.Produtos.Add(new Produto());

        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfra structure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());
        }
    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        foreach(var e in entries)
        {
            Console.WriteLine(e.Entity.ToString() + " - " + e.State);
        }
    }
}
As propriedades ainda não existem na classe Promocao, por isso iremos criá-la.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Promocao
    {
        public string Descricao { get; internal set; }
        public DateTime DataInicio { get; internal set; }
        public DateTime DataTermino { get; internal set; }
        public IList<Produto> Produtos { get; internal set; }
    }
}
. Para podermos usar a propriedade Produtos, é necessário colocarmos a classe Produto
como public. Como o Entity irá refletir isso no banco de dados? Sabemos que a classe 
Promocao ainda não tem a sua tabela representativa, faremos essa configuração.

. Na classe LojaContext, criaremos uma nova propriedade DbSet<Promocao> Promocoes.

using Microsoft.EntityFrameworkCore;
using System;

namespace Alura.Loja.Teste.ConsoleApp
{
    public class LojaContext : DbContext
    {
        public DbSet<Produto> Produtos { get; set; }
        public DbSet<Compra> Compras { get; set; }
        public DbSet<Promocao> Promocoes { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.
			UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=LojaDB;
			Trusted_Connection=true;")
        }
    }
}
. Se tentarmos usar o comando Add-Migration receberemos um erro informando que não 
possuímos um chave primária, por isso criaremos na classe promoção a propriedade Id. 
Em seguida, podemos finalmente adicionar a migração que chamaremos de Promocao. 
O comando completo será Add-Migration Promocao.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Promocao
    {
        public int Id { get; set; }
        public string Descricao { get; internal set; }
        public DateTime DataInicio { get; internal set; }
        public DateTime DataTermino { get; internal set; }
        public IList<Produto> Produtos { get; internal set; }
    }
}
 . Analisando a classe de migração Promocao, veremos que ele está criando um 
 coluna PromocaoId na tabela Produto. O Entity interpretou que cada produto 
 está associado a apenas um promoção. O que não faz sentido para a nossa aplicação.
 O que queremos é que a promoção acesse uma coleção de produtos, e o produto acesse
 uma coleção de promoções. Removeremos essa migração com Remove-Migration.

Para resolvermos isso, adicionaremos na classe Produto uma lista de promoções.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Produto
    {
        public int Id { get; internal set; }
        public int Nome { get; internal set; }
        public int Categoria { get; internal set; }
        public int PrecoUnitario { get; internal set; }
        public string Unidade { get; set; }
        public IList<Promocao> Promocoes { get; set; }

        public override string ToString()
        {
            return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, 
						{this.PrecoUnitario}";
        }
    }
}
. Dessa forma temos o relacionamento de muitas promoções para muitos produtos. 
Porém se tentarmos adicionar a migração teremos um erro. A versão 6 que é a 
anterior do Entity Framework Core, conseguia identificar as tabelas JOIN 
automaticamente. Mas na versão atual, que é um subset da versão anterior, foi 
deixado de fora (por enquanto) essa função.

//-------------------------------------------------------------------------

	* 6 - Aula 02 Mapeando chaves primárias compostas

 . Para termos a tabela de JOIN, criaremos uma classe que representará esse 
 relacionamento e será reconhecido pelo Entity. A classe se chamará PromocaoProduto.

namespace Alura.Loja.Testes.CosoleApp
{
    public class PromocaoProduto
    {
    }
}
A classe terá as propriedades ProdutoId, Produto, PromocaoId e Promocao:

namespace Alura.Loja.Testes.CosoleApp
{
    public class PromocaoProduto
    {
        public int ProdutoId { get; set; }
        public Produto produto { get; set; }
        public int PromocaoId { get; set; }
        public Promocao Promocao { get;  set; }
    }
}
 . Na classe Promocao, mudaremos o tipo da lista IList<Produto> para 
 IList<PromocaoProduto>:

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Promocao
    {
        public int Id { get; set; }
        public string Descricao { get; internal set; }
        public DateTime DataInicio { get; internal set; }
        public DateTime DataTermino { get; internal set; }
        public IList<PromocaoProduto> Produtos { get; internal set; }
    }
}
 . Na classe Produto também mudaremos o tipo da lista, de IList<Promocao> para 
 IList<PromocaoProduto>:

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Produto
    {
        public int Id { get; internal set; }
        public int Nome { get; internal set; }
        public int Categoria { get; internal set; }
        public int PrecoUnitario { get; internal set; }
        public string Unidade { get; set; }
        public IList<PromocaoProduto> Promocoes { get; set; }

        public override string ToString()
        {
            return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, 
			{this.PrecoUnitario}";
        }
    }
}
 . Antes de adicionarmos a migração, é necessário comentarmos o trecho de código 
 onde adicionamos um novo produto na promoção que simulamos na classe Program:

//promocaoDePascoa.Produtos.Add(new Produto());
//promocaoDePascoa.Produtos.Add(new Produto());
//promocaoDePascoa.Produtos.Add(new Produto());
 . Tentaremos adicionar a migração com o comando Add-Migration Promocao. 
 Receberemos um erro informando que é necessário um Id para ser a chave 
 primária da classe PromocaoProduto. Mas será que faz sentido? Não, por ser 
 uma classe de JOIN.

 . Podemos criar uma chave primária composta, que será identificada pelo ProdutoId
 e PromocaoId. Na classe LojaContext iremos sobrescrever outro método, chamado 
 OnModelCreating().

 . Esse método é executado no evento de criação do modelo. Podemos configurar 
 informado que a entidade PromocaoProduto tem a chave composta, com a composição 
 de ProdutoId e PromocaoId. A configuração ficará da seguinte maneira:

namespace Alura.Loja.Testes.ConsoleApp
{
    public class LojaContext : DbContext
    {
        public DbSet<Produto> Produtos { get; set; }
        public DbSet<Compra> Compras { get; set; }
        public DbSet<Promocao> Promocoes { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder
                .Entity<PromocaoProduto>()
                .HasKey(pp => new { pp.PromocaoId, pp.ProdutoId });
            base.OnModelCreating(modelBuilder);
        }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;
			Database=LojaDB;Trusted_Connection=true;")
        }
    }
}
 . Se executarmos o comando Add-Migration Promocao, a migração será criada com 
 sucesso. Analisando a classe de migração Promocao, veremos que o no método Up()
 será criado as tabelas Promocoes e PromocaoProduto. Detalhe que na tabela JOIN, 
 possui a chave composta, com as chaves estrangeiras de Produtos e Promocoes. 
 Assim se deletarmos um produto ou uma promoção, os registros da tabela 
 PromocaoProduto serão deletados em cascata.

 . Era isso que queríamos. Executaremos o comando Update-Database para que as 
 evoluções da sistema sejam aplicadas no banco de dados. Também será adicionado 
 na tabela de registros, que essa migração foi executada.

 //-------------------------------------------------------------------------

 No sistema bancário que Manoel está produzindo, chegou a hora de relacionar contas 
 a clientes. O requisito que Manoel precisa atender é: uma conta pode estar associada
 a vários clientes, e um cliente pode ter várias contas.

Suponha que as classes Conta e Cliente estejam especificadas desta maneira:

namespace Alura.Banco.Modelo
{
    public class Conta
    {
        public int Id { get; set; }
        public string Numero { get; set; }
        public double Saldo { get; set; }
    }

    public class Cliente
    {
        public int Id { get; set; }
        public string Nome { get; set; }
        public string CPF { get; set; }
    }
}
Para que o Entity consiga mapear o cenário Contas x Clientes (descrito no primeiro 
parágrafo) no banco de dados, selecione as alternativas que descrevem as mudanças 
que você vai precisar fazer em seu modelo.

O código da solução deve ficar parecido com:

namespace Alura.Banco.Modelo
{
    public class Conta
    {
        public int Id { get; set; }
        public string Numero { get; set; }
        public double Saldo { get; set; }
        public IList<ContaCliente> Clientes { get; set; }
    }

    public class Cliente
    {
        public int Id { get; set; }
        public string Nome { get; set; }
        public string CPF { get; set; }
        public IList<ContaCliente> Contas { get; set; }
    }

    public class ContaCliente
    {
        public int IdConta { get; set; }
        public int IdCliente { get; set; }
        public Conta Conta { get; set; }
        public Cliente Cliente { get; set; }
    }
}

 //-------------------------------------------------------------------------

	* 6 - Aula 05 Manipulando promoções e produtos

 . Criamos a tabela Promocao junto com a tabela de JOIN chamada de PromocaoProduto. 
 Agora cadastraremos uma promoção no banco de dados, para vermos o comportamento do 
 Entity com o relacionamento muito para muitos.

 . Na classe Program, tiraremos os comentários das linhas onde são incluídos os 
 produtos. Mas temos um problema, por conta da configuração que fizemos para ter o
 relacionamento muitos para muitos, o método Produtos.Add() não recebe mais um 
 Produto, e sim um PromocaoProduto.

 . Para não poluirmos o código de produção com uma classe interna, criaremos um 
 método na classe Promocao chamado IncluiProduto().

class Program
{
    static void Main(string[] args)
    {
        var promocaoDePascoa = new Promocao();
        promocaoDePascoa.Descricao = "Páscoa Feliz";
        promocaoDePascoa.DataInicio = DateTime.Now;
        promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);

        promocaoDePascoa.IncluiProduto(p1);
        promocaoDePascoa.IncluiProduto(p2);
        promocaoDePascoa.IncluiProduto(p3);

        using(var contexto = new LojaContext())
        {
            var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
            var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
            loggerFactory.AddProvider(SqlLoggerProvider.Create());
        }
    }
    // ...
}
Não podemos esquecer de instanciar os produtos p1, p2 e p3.

static void Main(string[] args)
{
    var p1 = new Produto();
    var p2 = new Produto();
    var p3 = new Produto();

    var promocaoDePascoa = new Promocao();
    promocaoDePascoa.Descricao = "Páscoa Feliz";
    promocaoDePascoa.DataInicio = DateTime.Now;
    promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);

    promocaoDePascoa.IncluiProduto(p1);
    promocaoDePascoa.IncluiProduto(p2);
    promocaoDePascoa.IncluiProduto(p3);

    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());
    }
}

 . Em seguida, implementaremos o método IncluiProduto() na classe Promocao. Para 
 não recebermos um erro, precisaremos instanciar a lista Produtos no construtor 
 da classe. Ela ficará da seguinte maneira:

public class Promocao
{
    public int Id { get; set; }
    public string Descricao { get; internal set; }
    public DateTime DataInicio { get; internal set; }
    public DateTime DataTermino { get; internal set; }
    public IList<PromocaoProduto> Produtos { get; internal set; }

    public Promocao()
    {
        this.Produtos = new List<PromocaoProduto>();
    }

    public void IncluiProduto(Produto produto)
    {
        this.Produtos.Add(new PromocaoProduto() { Produto = produto });
    }
}

 . Incluiremos os produtos no banco de dados, por isso os popularemos com alguns 
 valores. Em seguida, adicionaremos o promocaoDePascoa ao contexto do Entity e 
 exibir com o método ExibeEntries().

static void Main(string[] args)
{
    var p1 = new Produto() { Nome = "Suco de Laranja", Categoria = "Bebidas", PrecoUnitario = 8.79, Unidade = "Litros"};
    var p2 = new Produto() { Nome = "Café", Categoria = "Bebidas", PrecoUnitario = 12.45, Unidade = "Gramas"};
    var p3 = new Produto() { Nome = "Macarrão", Categoria = "Alimentos", PrecoUnitario = 4.23, Unidade = "Gramas"};

    var promocaoDePascoa = new Promocao();
    promocaoDePascoa.Descricao = "Páscoa Feliz";
    promocaoDePascoa.DataInicio = DateTime.Now;
    promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);

    promocaoDePascoa.IncluiProduto(p1);
    promocaoDePascoa.IncluiProduto(p2);
    promocaoDePascoa.IncluiProduto(p3);

    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        contexto.Promocoes.Add(promocaoDePascoa);
        ExibeEntries(contexto.ChangeTracker.Entries());
    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        // ...
    }
}

 . Executaremos a aplicação. Como resultado, veremos que o Entity passou a 
 monitorar as entidade Promocao, PromocaoProduto, além dos três produtos 
 adicionados. Todos os elementos adicionados ficaram com o estado Added. 
 Podemos colocar o SaveChanges() no código para que as promoções seja persistidas
 no banco de dados.

static void Main(string[] args)
{
    var p1 = new Produto() { Nome = "Suco de Laranja", Categoria = "Bebidas", PrecoUnitario = 8.79, Unidade = "Litros"};
    var p2 = new Produto() { Nome = "Café", Categoria = "Bebidas", PrecoUnitario = 12.45, Unidade = "Gramas"};
    var p3 = new Produto() { Nome = "Macarrão", Categoria = "Alimentos", PrecoUnitario = 4.23, Unidade = "Gramas"};

    var promocaoDePascoa = new Promocao();
    promocaoDePascoa.Descricao = "Páscoa Feliz";
    promocaoDePascoa.DataInicio = DateTime.Now;
    promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);

    promocaoDePascoa.IncluiProduto(p1);
    promocaoDePascoa.IncluiProduto(p2);
    promocaoDePascoa.IncluiProduto(p3);

    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        contexto.Promocoes.Add(promocaoDePascoa);
        contexto.SaveChanges();

    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        // ...
    }
}

 . Novamente executando a aplicação, tudo funciona como o esperado. Olhando 
 no banco de dados, veremos a promoção cadastrada na tabela Promocao, e na 
 tabela Produto os três novos produtos também estão cadastrados.

 . Mas o que acontece se deletarmos a promoção? Faremos um teste pegando a 
 promoção do banco e chamando o método contexto.Promocoes.Remove().

static void Main(string[] args)
{
    var p1 = new Produto() { Nome = "Suco de Laranja", Categoria = "Bebidas", PrecoUnitario = 8.79, Unidade = "Litros"};
    var p2 = new Produto() { Nome = "Café", Categoria = "Bebidas", PrecoUnitario = 12.45, Unidade = "Gramas"};
    var p3 = new Produto() { Nome = "Macarrão", Categoria = "Alimentos", PrecoUnitario = 4.23, Unidade = "Gramas"};

    var promocaoDePascoa = new Promocao();
    promocaoDePascoa.Descricao = "Páscoa Feliz";
    promocaoDePascoa.DataInicio = DateTime.Now;
    promocaoDePascoa.DataTermino = DateTime.Now.AddMonths(3);

    promocaoDePascoa.IncluiProduto(p1);
    promocaoDePascoa.IncluiProduto(p2);
    promocaoDePascoa.IncluiProduto(p3);

    using(var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        //contexto.Promocoes.Add(promocaoDePascoa);
        var promocao = contexto.Promocoes.Find(3);
        contexto.Promocoes.Remove(promocao);
        contexto.SaveChanges();
    }
    // ...
}
 . A promoção será deletada, junto com o elemento de PromocaoProduto pelo efeito
 de cascata, já que eles são completamente interligados. Mas os produtos 
 cadastrados ainda permanecem no banco.

 //-------------------------------------------------------------------------
 //-------------------------------------------------------------------------
 //-------------------------------------------------------------------------

	* 7 - Aula 01 - Relacionamento um para um

 . Na aula anterior vimos como o Entity trata o relacionamento muitos para muitos, 
 usando o conceito da classe Promocao. Nessa aula aprenderemos o relacionamento de
 um para um.

 . A ideia é criarmos uma entidade para os clientes que compram na loja. Além disso,
 também criaremos uma outra entidade para o endereço de entrega.

 . Antes de começarmos, iremos mover todo o conteúdo do método Main() para um novo
 método chamado MuitosParaMuitos(). Com o método Main() vazio, começaremos 
 instanciando um objeto da classe Cliente.

class Program
{
    static void Main(string[] args)
    {
        var fulano = new Cliente();
        fulano.Nome = "Fulaninho de Tal";
    }

    private static void MuitosParaMuitos()
    {
        // ...
    }

    private static void ExibeEntries(IEnumerable<EntityEntry> entries)
    {
        // ...
    }
}

 . Como a classe Cliente ainda não existe, iremos criá-la. Lembrando que além das 
 propriedades Nome e EnderecoDeEntrega, criaremos a propriedade Id para persistirmos
 no banco de dados.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Cliente
    {
        public int Id { get; set; }
        public string Nome { get; internal set; }
        public Endereco EnderecoDeEntrega { get; set; }
    }
}

 . Criaremos agora a classe Endereco com as propriedades Numero, Logradouro, 
 Complemento, Bairro e Cidade.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Endereco
    {
        public int Numero { get; internal set; }
        public string Logradouro { get; internal set; }
        public string Complemento { get; internal set; }
        public string Bairro { get; internal set; }
        public string Cidade { get; internal set; }
    }
}

 . Voltaremos para o método Main() para popularmos as informações de endereço e
 associarmos com o cliente. Já instanciaremos o objeto de LojaContext para 
 persistirmos.

static void Main(string[] args)
{
    var fulano = new Cliente();
    fulano.Nome = "Fulaninho de Tal";
    fulano.EnderecoDeEntrega = new Endereco()
    {
        Numero = 12,
        Logradouro = "Rua dos Inválidos",
        Complemento = "sobrado",
        Bairro = "Centro",
        Cidade = "Cidade"
    };

    using (var contexto = new LojaContext())
    {
        contexto.Clientes.Add(fulano);
        contexto.SaveChanges();
    }
}

 . Dentro da classe LojaContext iremos criar a propriedade para o cliente.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class LojaContext : DbContext
    {
        public DbSet<Produto> Produtos { get; set; }
        public DbSet<Compras> Compras { get; set; }
        public DbSet<Promocao> Promocoes { get; set; }
        public DbSet<Cliente> Clientes { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;
			Database=LojaDB;Trusted_Connection=true;")
        }
    }
}

 . Fizemos mais uma evolução da aplicação. Agora precisamos sincronizar com o 
 banco de dados.

 //-------------------------------------------------------------------------

	* 7 - Aula 02 - Escondendo informações específicas do banco

 . Abriremos o Console do NuGet, e usaremos o comando Add-Migration Cliente para 
 adicionar essa migração. Ao executarmos receberemos um erro informando que a 
 classe Endereco precisa de um Id.

 . Como o Entity soube que queríamos persistir a classe Endereco se não criamos 
 uma propriedade no LojaContext? Quando definimos uma entidade no LojaContext, 
 ele navega por suas propriedades. Dessa forma, caso o valor seja um referência 
 de outra classe - como a Endereco - , ela automaticamente passa a ser controlada 
 pelo Entity.

 . A decisão de mapear uma classe no LojaContext fica de acordo com a lógica de 
 negócio. Caso seja necessário manipular os atributos da classe de forma independente,
 criar um propriedade em LojaContext fará sentido. Em nosso caso não criaremos, nós 
 apenas iremos manipular o endereço por meio da classe Cliente.

 . Para resolvermos nosso problema, bastaríamos criar uma propriedade Id ou 
 EnderecoId, para que o Entity mapeie automaticamente como chave primária. Mas 
 existem cenários de relacionamentos um para um, onde a tabela dependente - Endereco -
 assume o Id da tabela principal, a tabela Cliente.

 . Usaremos este exemplo para aprendermos que não precisamos necessariamente ter um
 chave primária em nossa classe. Como colocar um tributo ClienteId não faz sentido
 para o modelo, podemos ensinar ao Entity por meio do método OnModelCreating() da 
 classe LojaContext.

 . Dentro do método OnModelCreating(), chamaremos o modelBuilder dizendo que a 
 entidade Endereco possui uma propriedade ClienteId e por último criaremos a chave, 
 o método ficará da seguinte maneira:

internal class LojaContext : DbContext
{
    // ...

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<PromocaoProduto>()
            .HasKey(pp => new { pp.PromocaoId, pp.ProdutoId });

        modelBuilder
            .Entity<Endereco>()
            .Property("ClienteId");
    }
    // ...
}

 . O nome desse conceito para o Entity é Shadow Property, ou seja, uma propriedade 
 que está escondida, ficando apenas no banco de dados. Podemos rodar o comando 
 Add-Migration Cliente.

 . Ao executarmos receberemos outro erro, mas desta vez é informado que para usarmos
 Shadow Property é necessário passar o tipo da propriedade. Basta adicionarmos na 
 definição da propriedade "ClienteId".

internal class LojaContext : DbContext
{
    // ...

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<PromocaoProduto>()
            .HasKey(pp => new { pp.PromocaoId, pp.ProdutoId });

        modelBuilder
            .Entity<Endereco>()
            .Property<int>("ClienteId");

        modelBuilder
            .Entity<Endereco>()
            .HasKey("ClienteId");
    }
    // ...
}

 . Executaremos o comando Add-Migration Cliente novamente. A migração será 
 criada, mas o Entity interpretou errado e considerou que a classe principal era 
 a Endereco e a dependente era a Cliente, por esse motivo a coluna ClienteId foi 
 criada em Cliente. Outro detalhe é que o nome da tabela ficou como Endereco no 
 singular, o que não é o ideal já que a tabela armazenará diversos endereços.

 . Novamente no Console, removeremos a migração com Remove-Migration. Veremos 
 como alterar do nome da tabela e resolver a dependência entre Cliente e Endereco.

 //-------------------------------------------------------------------------

	* 7 - Aula 05 - Mudando o nome da tabela

 . Quando criamos uma propriedade em LojaContext, o Entity usa o nome da 
 propriedade como nome da tabela. O problema é que não temos uma propriedade 
 criada para Endereco. Como faremos para alterar o nome da tabela?

 . Usaremos também o modelBuilder no método OnModelCreating(). Com o objeto 
 modelBuilder, mapearemos a entidade Endereco para a tabela Enderecos. O método 
 ficará da seguinte maneira:

internal class LojaContext : DbContext
{
    // ...
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity<PromocaoProduto>()
            .HasKey(pp => new { pp.PromocaoId, pp.ProdutoId });

        modelBuilder
            .Entity<Endereco>()
            .ToTable("Enderecos");

        modelBuilder
            .Entity<Endereco>()
            .Property<int>("ClienteId");

        modelBuilder
            .Entity<Endereco>()
            .HasKey("ClienteId");
    }
    // ...
}
 
 . Resolvemos o problema do nome da tabela. Porém ainda precisamos fazer com 
 que a tabela Enderecos seja dependente da tabela Clientes. Criaremos na classe
 Endereco uma propriedade que faz referencia para a classe Cliente.

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Endereco
    {
        public int Numero { get; internal set; }
        public string Logradouro { get; internal set; }
        public string Complemento { get; internal set; }
        public string Bairro { get; internal set; }
        public string Cidade { get; internal set; }
        public Cliente Cliente { get; set; }
    }
}

 . A propriedade Cliente faz sentido em nosso modelo, afinal um endereço precisa 
 de um cliente. Executaremos o comando Add-Migration Cliente e veremos que a 
 migração será criada. Um aviso será dado no Console informando que a entidade 
 endereço contém uma propriedade com o estado Shadow Property.

 . Analisando a classe de migração, veremos que primeiro ocorrerá a criação da 
 tabela Clientes com as propriedades Nome e EnderecoDeEntrega. Em seguida a 
 tabela Enderecos será criada com suas propriedades, inclusive com a chave 
 primária sendo a estrangeira de Clientes, trabalhando em forma de cascata.

 . A migração está fazendo sentido. Para sincronizarmos com o banco de dados,
 usaremos o comando SQL Update-Database.

 . Com as tabelas criadas, executaremos a aplicação para persistirmos as 
 informações que configuramos no método Main() da classe Program:

static void Main(string[] args)
{
    var fulano = new Cliente();
    fulano.Nome = "Fulaninho de Tal";
    fulano.EnderecoDeEntrega = new Endereco()
    {
        Numero = 12,
        Logradouro = "Rua dos Inválidos",
        Complemento = "sobrado",
        Bairro = "Centro",
        Cidade = "Cidade"
    };

    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        contexto.Clientes.Add(fulano);
        contexto.SaveChanges();
    }
}

 . O Entity inseriu as informações em Clientes e em seguida Enderecos, sendo que
 a chave primária do endereço é a mesma de cliente. Com isso entendemos como 
 funciona os diversos tipo de relacionamentos.

 . Na próxima aula veremos como recuperar objetos relacionados.

 . Quando executado, o Add-Migration o ModelBuilder pode se perder, caso isso 
 aconteça, ele pode gerar primeiro a tabela Enderecos antes da Clientes e não 
 gera a dependência em cascata. Para corrigir esse problema basta adicionar na
 classe Endereco a propriedade ClienteId, não criar a ShadowProperty e referenciar
 a chave primaria o ClienteId.

 //-------------------------------------------------------------------------
 //-------------------------------------------------------------------------
 //-------------------------------------------------------------------------

	* 8 - Aula 01 - Aplicando condições nas consultas

 . Nas aulas anteriores conversamos sobre relacionamentos. Nessa aula usaremos 
 esses relacionamentos para montarmos querys um pouco mais complexas.

 . Como já fizemos em aulas anteriores, vamos mover todo o código contido no 
 método Main() para um outro método chamado UmParaUm(). Em seguida criaremos 
 o objeto de LojaContext e uma promoção para janeiro.

class Program
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var promocao = new Promocao();
            promocao.Descricao = "Queima Total 2017";
            promocao.DataInicio = new DateTime(2017, 1, 1);
            promocao.DataTermino = new DateTime(2017, 1, 31);
        }
    }
    // ...
}

 . Adicionaremos produtos nessa promoção, mas ao invés de criarmos novos produtos, 
 pegaremos do banco de dados todos os produtos da categoria "Bebidas". Estamos 
 acostumados a pegar todos os produtos usando apenas o ToList(), mas o LINQ do 
 C# possui métodos que nos auxiliam. Um desses métodos é o Where() que recebe uma 
 expressão lambda booleana. Depois de pegar os produtos, adicionaremos dentro da
 promoção e a promoção no contexto. A classe ficará da seguinte maneira:

class Program
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var promocao = new Promocao();
            promocao.Descricao = "Queima Total Janeiro 2017";
            promocao.DataInicio = new DateTime(2017, 1, 1);
            promocao.DataTermino = new DateTime(2017, 1, 31);

            var produtos = contexto
                .Produtos
                .Where(p => p.Categoria == "Bebidas")
                .ToList();

            foreach(var item in produtos)
            {
                promocao.IncluiProduto(item);
            }
            contexto.Promocoes.Add(promocao);
        }
    }
    // ...
}

 . Após o contexto.Promocoes.Add(promocao) chamaremos o método ExibeEntries() 
 para verificarmos como o Entity está tratando as informações.

class Program
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var promocao = new Promocao();
            promocao.Descricao = "Queima Total Janeiro 2017";
            promocao.DataInicio = new DateTime(2017, 1, 1);
            promocao.DataTermino= new DateTime(2017, 1, 31);

            var produtos = contexto
                .Produtos
                .Where(p => p.Categoria == "Bebidas")
                .ToList();

            foreach(var item in produtos)
            {
                promocao.IncluiProduto(item);
            }
            contexto.Promocoes.Add(promocao);
        ExibeEntries(contexto.ChangeTracker.Entries());
        }
    }
    // ...
}

 . Veremos que ele buscou apenas produtos com a categoria "Bebidas" (caso não 
 tenha nada no banco cadastre alguns produtos para testar). Em seguida ele 
 adicionou em promocao e deixou com o estado Added.

 . Como tudo parece estar funcionando, adicionaremos o contexto.SaveChanges(). 
 Fora do escopo do contexto, criaremos outro objeto de LojaContext() para 
 mostrarmos os produtos cadastrados na promocao. Quando fechamos um contexto do 
 Entity, os objetos deixam de ser rastreados por aquele contexto.

class Program
{
    static void Main(string[] args)
    {
        using(var contexto = new LojaContext())
        {
            var promocao = new Promocao();
            promocao.Descricao = "Queima Total Janeiro 2017";
            promocao.DataInicio = new DateTime(2017, 1, 1);
            promocao.DataTermino = new DateTime(2017, 1, 31);

            var produtos = contexto
                .Produtos
                .Where(p => p.Categoria == "Bebidas")
                .ToList();

            foreach(var item in produtos)
            {
                promocao.IncluiProduto(item);
            }

            contexto.Promocoes.Add(promocao);
        ExibeEntries(contexto.ChangeTracker.Entries());
            contexto.SaveChanges();
        }

        using(var contexto2 = new LojaContext())
        {
            var promocao = contexto2.Promocoes.FirstOrDefault();
            Console.WriteLine("\nMotrando os produtos da promoção...");
            foreach(var item in promocao.Produtos)
            {
                Console.WriteLine(item.Produto);
            }
        }
    }
    // ...
}

 . Após executarmos a aplicação veremos que o primeiro contexto fez o SELECT 
 em Produtos com a categoria "Bebida", os produtos foram adicionados no Change 
 Tracker, e então foi feito o INSERT em Promocoes e em PromocaoProduto.

 . Já o segundo contexto fez o SELECT na primeira promoção e não mostrou nada. 
 Olhando no banco de dados vemos que os produtos foram adicionados no 
 ProdutoPromocao, lembrando que para isso é necessário que os produtos existam 
 no banco.

 . O próximo passo é descobrir por que ele não está mostrando os produtos.

 //-------------------------------------------------------------------------

	* 8 - Aula 03 - Como realizar joins entre entidades relacionadas

 . Queremos saber porque os produtos da promoção não estão sendo recuperados, 
 quando buscamos com outro contexto do Entity. Na verdade, esse tipo de comportamento
 de não recuperar as entidade relacionadas junto com o SELECT é padrão em várias 
 ferramentas de ORM.

 . Se as ferramentas de ORM não tivessem esse tipo de comportamento, seria buscado 
 para a memória todas as entidades relacionadas a classe, o que poderia trazer 
 problemas de performance. Temos que informar que queremos entidades relacionadas
 explicitamente por meio de métodos.

 . Antes começarmos a trabalhar na busca, extrairemos todo o código que insere a 
 promoção no banco para um método chamado IncluirPromocao(). Deixaremos no Main() 
 apenas o código onde buscamos pelos produtos da promoção:

class Program
{
    static void Main(string[] args)
    {
        using(var contexto2 = new LojaContext())
        {
            var promocao = contexto2.Promocoes.FirstOrDefault();
            Console.WriteLine("\nMotrando os produtos da promoção...");
            foreach(var item in promocao.Produtos)
            {
                Console.WriteLine(item.Produto);
            }
        }
    }
    // ...
}

 . O método que precisamos invocar é o Include(), que incluirá a entidade relacionada.
 Porém como queremos os produtos, precisamos chamar a entidade PromocaoProduto. Para
 inclui-lá usaremos o método ThenInclude(), ou seja, buscaremos uma Promocao que 
 busca uma PromocaoProduto, onde podemos acessar o Produto. A busca será feita da 
 seguinte forma:

class Program
{
    static void Main(string[] args)
    {
        using(var contexto2 = new LojaContext())
        {
            var promocao = contexto2
                .Promocoes
                .Include(p => p.Produtos)
                .ThenInclude(pp => pp.Produto)
                .FirstOrDefault();

            Console.WriteLine("\nMotrando os produtos da promoção...");
            foreach(var item in promocao.Produtos)
            {
                Console.WriteLine(item.Produto);
            }
        }
    }
    // ...
}

 . Executaremos a aplicação. Como resultado, veremos um SELECT em Promocoes, mas 
 além disso, temos outro SELECT para trazer os produtos. É dessa forma que o Entity
 utiliza para buscar entidades relacionadas e manter a performance.

 . Veremos como fazer essas buscas com relacionamentos um para um e um para muitos.

 //-------------------------------------------------------------------------

	Para saber mais: sobrecarga de Include

 . O método Include possui uma segunda sobrecarga, que permite informarmos como 
 argumento de entrada uma string com o nome da propriedade de navegação a ser 
 incluída no join. A vantagem dessa abordagem é que não precisamos usar outros 
 métodos ThenInclude para continuar a navegação em outras entidades. Por exemplo, 
 para o exemplo Cliente x Conta, poderíamos fazer:

 var lista = contexto.Clientes.Include("Contas.Conta");

 . A desvantagem é que se o nome da propriedade mudar, teremos que lembrar todos 
 os lugares onde fizemos isso, porque não teremos ajuda do compilador.

 //-------------------------------------------------------------------------

	* 8 - Aula 06 - Corrigindo o modelo para recuperar objetos relacionados

Exploraremos o relacionamento um para um entre Cliente e Endereco. Como já fizemos anteriormente, vamos colocar todo o conteúdo do método Main() e um método chamado ExibeProdutosDaPromocao(). Dentro do Main() criaremos apenas um objeto de contexto do Entity e deixaremos os Logger.

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());
    }
}
Buscaremos a propriedade Logradouro do endereço de um Cliente. Porém antes precisamos buscar o cliente, faremos isso usando o FirstOrDefault(). Como a propriedade EnderecoDeEntrega já está disponível, podemos acessar o Logradouro.

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var cliente = contexto.Clientes.FirstOrDefault();

        Console.WriteLine($"Endereço de entrega: {cliente.EnderecoDeEntrega.Logradouro}");
    }
}
Ao executarmos a aplicação ocorrerá um exceção. Isso aconteceu porque acessamos a propriedade Logradouro nula, o Entity não carregou essa propriedade. Incluiremos a entidade em nossa busca:

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var cliente = contexto
            .Clientes
            .Include(c => c.EnderecoDeEntrega)
            .FirstOrDefault();

        Console.WriteLine($"Endereço de entrega: {cliente.EnderecoDeEntrega.Logradouro}");
    }
}
Executaremos a aplicação e veremos que funcionou perfeitamente. O SELECT que o Entity utilizou foi com LEFT JOIN, pelo fato do endereço não ser obrigatório para o cliente.

Continuaremos explorando as consultas com relacionamento, pegaremos as compras de um produto. Primeiro pegaremos um produto qualquer - no nosso caso o produto com uma compra era o com Id 9004 - passando o seu Id pelo Where().

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var cliente = contexto
            .Clientes
            .Include(c => c.EnderecoDeEntrega)
            .FirstOrDefault();

        Console.WriteLine($"Endereço de entrega: {cliente.EnderecoDeEntrega.Logradouro}");

        var produto = contexto
            .Produtos
            .Where(p => p.Id == 9004)
            .FirstOrDefault();
    }
}
Com esse produto faremos um foreach na listagem produto.Compras. Porém não temos a lista de Compras pelo fato de que o Entity não nos obrigar a criá-la. Adicionaremos a lista na classe Produto:

namespace Alura.Loja.Testes.ConsoleApp
{
    public class Produto
    {
        public int Id { get; internal set; }
        public int Nome { get; internal set; }
        public int Categoria { get; internal set; }
        public int PrecoUnitario { get; internal set; }
        public string Unidade { get; set; }
        public IList<PromocaoProduto> Promocoes { get; set; }
        public IList<Compra> Compras { get; set; }

        public override string ToString()
        {
            return $"Produto: {this.Id}, {this.Nome}, {this.Categoria}, {this.PrecoUnitario}";
        }
    }
}
Antes de inciarmos a iteração pela lista, precisamos incluir as compras no Include().

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var cliente = contexto
            .Clientes
            .Include(c => c.EnderecoDeEntrega)
            .FirstOrDefault();

        Console.WriteLine($"Endereço de entrega: {cliente.EnderecoDeEntrega.Logradouro}");

        var produto = contexto
            .Produtos
            .Include(p => p.Compras)
            .Where(p => p.Id == 9004)
            .FirstOrDefault();

        Console.WriteLine($"Mostrando as compras do produto {produto.Nome}");
        foreach(var item in produto.Compras)
        {
            Console.WriteLine(item);
        }
    }
}
Executaremos a aplicação e como resultado, veremos que o Entity buscou o produto com o Id 9004, em seguida ele fez um INNER JOIN de Compras com Produtos para pegar as compras, e por último foi mostrado a compra. A única coisa que precisamos fazer é uma propriedade, onde navegaremos para o lado onde temos muitos.

 . Vimos como trabalhar com buscas de relacionamentos muitos para muitos, um para um e um para muitos. Mas e se quiséssemos buscar as compras acima de um valor determinado? É o nosso próximo passo!

 //-------------------------------------------------------------------------

	* 8 - Aula 08 - Populando coleções após a carga da entidade principal

 . Queremos filtrar as compras acima de R$ 10,00. Não podemos usar o Where() para 
 filtrar o preço da compra, justamente por estarmos acessando a partir de Produtos. 
 O Include() também não será útil nessa situação. O que faremos é um segundo SELECT
 para filtrar as compras do produto que já buscamos.

 . Com o objeto contexto, chamaremos o método Entry() passando a referência de 
 produto. Após, pegaremos a coleção da propriedade Compra com o método 
 Collection(p => p.Compras). Em seguida faremos uma Query(), que filtrará com a 
 condição Where(c => c.Preco > 10). Por último, carregaremos com Load() na referência
 passada no Entry(). O código ficará da seguinte maneira:

static void Main(string[] args)
{
    using (var contexto = new LojaContext())
    {
        var serviceProvider = contexto.GetInfrastructure<IServiceProvider>();
        var loggerFactory = serviceProvider.GetService<ILoggerFactory>();
        loggerFactory.AddProvider(SqlLoggerProvider.Create());

        var cliente = contexto
            .Clientes
            .Include(c => c.EnderecoDeEntrega)
            .FirstOrDefault();

        Console.WriteLine($"Endereço de entrega: {cliente.EnderecoDeEntrega.Logradouro}");

        var produto = contexto
            .Produtos
            .Where(p => p.Id == 9004)
            .FirstOrDefault();

        contexto.Entry(produto)
            .Collection(p => p.Compras)
            .Query()
            .Where(c => c.Preco > 10)
            .Load();

        Console.WriteLine($"Mostrando as compras do produto {produto.Nome}");
        foreach(var item in produto.Compras)
        {
            Console.WriteLine("\t" + item);
        }
    }
}

 . Executaremos a aplicação com "Ctrl + F5". Poderemos ver que foi executado um 
 SELECT em Produtos no banco de dados, buscando o produto com o Id passado no 
 filtro Where(). Em seguida foi feito um segundo SELECT em Compras, filtrando pelo 
 Id do produto passado no Entry() e pelo preço. Por fim, serão apresentados os 
 produtos com preço acima de R$ 10,00.

 . Esse cenário é bastante utilizado quando queremos aplicar filtros em objetos 
 relacionados da aplicação. Esta estratégia é conhecida como Carregamento Explícito,
 onde trazemos só o que nos interessa.


 //-------------------------------------------------------------------------

	ENCERRAMENTO - O QUE APRENDEMOS

 . Finalizamos o curso de Entity Framework Core! Faremos um resumo sobre o que 
 aprendemos durante o curso.

 . Vimos que para trabalhar com o modelo de negócios e persisti-lo no banco de 
 dados era algo extremamente trabalhoso. O programador era responsável por 
 gerenciar e manter o código que se comunicava com o banco. Qualquer mudança na 
 lógica de negócio, gerava uma série de impactos nas classes de acesso aos dados.

 . Em seguida, Começamos o uso do Entity após a instalação dos pacotes, passando 
 a substituir todo o trabalho, permitindo forcarmos na lógica de negócio. Aprendemos
 como o Entity gerencia os comandos SQL, trabalhando com a DML (INSERT, SELECT, 
 UPDATE e DELETE) para manipular os dados.

manipulação de dados

 . Para gerenciar quais objetos e quais comandos SQL precisavam ser emitidos para 
 o banco de dados, o Entity usava um recurso chamado Change Tracker, onde era 
 armazenado os estados de cada objeto.

change tracker

 . Enquanto a aplicação evoluía, era necessário sincronizá-la com o banco de dados, 
 onde Entity também nos auxilia com a DDL (CREATE, DROP, ALTER, RENAME). Utilizamos
 o conceito de migrações (Migrations), onde as alterações no negócio são aplicadas 
 ao banco. As migrações eram feitas por meio de classes, que tinha os métodos Up() 
 para subir e Down() para descer de versão.

 . Instalamos no NuGet, um pacote para utilizarmos diversos comandos que trabalham 
 com as migrações.

Add-Migration
Remove-Migration
Update-Database

 . Todas as alterações no banco de dados eram armazenadas na tabela 
 __EFMigrationHistory. A tabela indicava quais migrações tinham sido aplicadas no 
 banco de dados.

 . Após entender como o Entity funciona, aprendemos como ele trabalha e gerencia 
 os relacionamentos entre classe. Os relacionamentos eram um para um, um para 
 muitos e muitos para muitos. Porém o Entity Core não gerencia sozinho as tabelas 
 JOIN, por isso contornamos criando uma classe específica.

tabela de relacionamentos

Para recuperarmos dados relacionados, usamos métodos específicos:

Include()
ThenInclude()
Load()
Esse foi o curso de Entity Framework Core. Te vejo nos próximos cursos!

 //-------------------------------------------------------------------------






